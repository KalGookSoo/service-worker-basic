# 서비스 워커 기초 기출문제 - 정답 및 해설

이 문서는 서비스 워커 기초 기출문제에 대한 정답과 해설을 제공합니다.

## 목차
- [서비스 워커 소개](#서비스-워커-소개)
- [서비스 워커 생명주기](#서비스-워커-생명주기)
- [서비스 워커와 캐싱](#서비스-워커와-캐싱)
- [서비스 워커 이벤트 처리](#서비스-워커-이벤트-처리)
- [프로그레시브 웹 앱(PWA)](#프로그레시브-웹-앱pwa)
- [서비스 워커 고급 주제](#서비스-워커-고급-주제)

## 서비스 워커 소개

### 문제 1
**문제**: 서비스 워커의 가장 기본적인 특성은 무엇인가요?

**정답**: 브라우저와 네트워크 사이에서 프록시 역할을 한다

**해설**: 서비스 워커는 웹 애플리케이션과 네트워크 사이에서 프록시 역할을 하는 것이 가장 기본적인 특성입니다. 이를 통해 네트워크 요청을 가로채고 수정할 수 있으며, 오프라인 경험을 제공할 수 있습니다. 서비스 워커는 메인 스레드가 아닌 별도의 워커 스레드에서 실행되며, DOM에 직접 접근할 수 없고, 비동기적으로 작동합니다.

### 문제 2
**문제**: 서비스 워커를 사용하기 위해 반드시 필요한 프로토콜은 무엇인가요? (개발 환경 제외)

**정답**: HTTPS

**해설**: 서비스 워커는 보안상의 이유로 HTTPS 환경에서만 작동하도록 설계되었습니다. 서비스 워커는 네트워크 요청을 가로채고 수정할 수 있는 강력한 기능을 가지고 있기 때문에, 중간자 공격을 방지하기 위해 HTTPS가 필수적입니다. 개발 목적으로는 localhost나 127.0.0.1과 같은 로컬 환경에서는 HTTPS 없이도 서비스 워커를 사용할 수 있습니다.

### 문제 3
**문제**: 서비스 워커와 웹 워커의 차이점으로 올바른 것을 모두 고르세요.

**정답**: 
- 서비스 워커는 페이지가 닫힌 후에도 실행될 수 있다
- 서비스 워커는 네트워크 요청을 가로챌 수 있다
- 서비스 워커는 여러 페이지에서 공유될 수 있다
- 웹 워커는 HTTPS 없이도 사용할 수 있다

**해설**: 
- 서비스 워커는 페이지가 닫힌 후에도 실행될 수 있습니다. 이는 서비스 워커가 페이지와 독립적인 생명주기를 가지기 때문입니다.
- 웹 워커는 DOM에 직접 접근할 수 없습니다. 이는 서비스 워커와 마찬가지로 웹 워커도 별도의 스레드에서 실행되기 때문입니다.
- 서비스 워커는 네트워크 요청을 가로챌 수 있습니다. 이는 서비스 워커의 핵심 기능 중 하나로, fetch 이벤트를 통해 구현됩니다.
- 서비스 워커는 여러 페이지에서 공유될 수 있습니다. 동일한 스코프 내의 모든 페이지는 같은 서비스 워커를 사용합니다.
- 웹 워커는 HTTPS 없이도 사용할 수 있습니다. 서비스 워커와 달리 웹 워커는 보안상의 이유로 HTTPS를 강제하지 않습니다.

### 문제 4
**문제**: 다음 중 서비스 워커 지원 여부를 확인하는 올바른 코드는?

**정답**: `if ('serviceWorker' in navigator) { ... }`

**해설**: 서비스 워커 지원 여부를 확인하는 표준적인 방법은 'serviceWorker' 속성이 navigator 객체에 존재하는지 확인하는 것입니다. 이 코드는 브라우저가 서비스 워커를 지원하는 경우에만 조건문 내부의 코드를 실행합니다. 다른 옵션들은 유효한 JavaScript 구문이 아니거나, 서비스 워커 지원 여부를 올바르게 확인하지 못합니다.

## 서비스 워커 생명주기

### 문제 5
**문제**: 서비스 워커의 생명주기 상태 중 올바른 순서는?

**정답**: 설치(installing) → 대기(waiting) → 활성화(activating) → 활성(active)

**해설**: 서비스 워커의 생명주기는 설치(installing), 대기(waiting), 활성화(activating), 활성(active) 순서로 진행됩니다. 서비스 워커 스크립트가 다운로드되면 설치 단계가 시작되고, 설치가 완료되면 대기 상태로 전환됩니다. 이전 서비스 워커가 없거나 skipWaiting()이 호출된 경우 바로 활성화 단계로 진행되며, 활성화가 완료되면 활성 상태가 됩니다.

### 문제 6
**문제**: 서비스 워커 설치 중에 리소스를 미리 캐싱하는 이벤트는?

**정답**: install

**해설**: 서비스 워커의 install 이벤트는 서비스 워커가 설치될 때 발생하며, 이 시점에서 필요한 리소스를 미리 캐싱하는 작업을 수행합니다. 이를 통해 오프라인 상태에서도 웹 애플리케이션이 작동할 수 있도록 준비합니다. activate 이벤트는 서비스 워커가 활성화될 때 발생하며, fetch 이벤트는 네트워크 요청이 발생할 때 발생합니다.

### 문제 7
**문제**: 서비스 워커 스크립트가 업데이트되었을 때 즉시 활성화하기 위해 사용하는 메서드는?

**정답**: self.skipWaiting()

**해설**: self.skipWaiting() 메서드는 대기 상태의 서비스 워커가 즉시 활성화 단계로 진행되도록 합니다. 일반적으로 서비스 워커가 업데이트되면 이전 서비스 워커가 종료될 때까지 대기 상태로 남아있지만, skipWaiting()을 호출하면 이 대기 과정을 건너뛰고 즉시 활성화됩니다. 이는 주로 install 이벤트 핸들러 내에서 사용됩니다.

### 문제 8
**문제**: 서비스 워커 등록 시 스코프를 지정하는 올바른 방법은?

**정답**: `navigator.serviceWorker.register('/sw.js', { scope: '/app/' })`

**해설**: 서비스 워커의 스코프는 register() 메서드의 두 번째 매개변수로 객체를 전달하고, 그 객체의 scope 속성을 통해 지정합니다. 스코프는 서비스 워커가 제어할 수 있는 페이지의 범위를 결정합니다. 기본적으로 서비스 워커 파일의 위치를 기준으로 스코프가 설정되지만, 위 코드와 같이 명시적으로 지정할 수도 있습니다.

### 문제 9
**문제**: 새로 설치된 서비스 워커가 활성화된 후 모든 클라이언트를 즉시 제어하도록 하는 메서드는?

**정답**: clients.claim()

**해설**: clients.claim() 메서드는 활성화된 서비스 워커가 해당 스코프 내의 모든 클라이언트(페이지)를 즉시 제어하도록 합니다. 일반적으로 서비스 워커는 새로고침 후에만 페이지를 제어하기 시작하지만, clients.claim()을 호출하면 활성화 즉시 제어권을 가져올 수 있습니다. 이는 주로 activate 이벤트 핸들러 내에서 사용됩니다.

## 서비스 워커와 캐싱

### 문제 10
**문제**: Cache API에서 캐시를 열거나 생성하는 메서드는?

**정답**: caches.open()

**해설**: caches.open() 메서드는 지정된 이름의 캐시를 열거나, 해당 이름의 캐시가 없는 경우 새로 생성합니다. 이 메서드는 Promise를 반환하며, 이 Promise는 캐시 객체로 해결됩니다. 이 캐시 객체를 통해 캐시에 항목을 추가하거나 검색할 수 있습니다. caches.create(), caches.get(), caches.init()은 실제 Cache API에 존재하지 않는 메서드입니다.

### 문제 11
**문제**: 다음 중 서비스 워커에서 사용할 수 있는 캐싱 전략이 아닌 것은?

**정답**: Server-Side Rendering

**해설**: Server-Side Rendering(SSR)은 서버에서 HTML을 생성하여 클라이언트에 전송하는 기술로, 서비스 워커의 캐싱 전략과는 관련이 없습니다. Cache First, Network First, Stale-While-Revalidate는 모두 서비스 워커에서 사용할 수 있는 캐싱 전략입니다. Cache First는 캐시를 먼저 확인하고 없으면 네트워크에 요청하는 전략, Network First는 네트워크에 먼저 요청하고 실패하면 캐시를 사용하는 전략, Stale-While-Revalidate는 캐시된 응답을 먼저 제공하고 백그라운드에서 네트워크 요청을 통해 캐시를 업데이트하는 전략입니다.

### 문제 12
**문제**: 네트워크 요청을 먼저 시도하고 실패할 경우 캐시에서 응답을 제공하는 전략은?

**정답**: Network First

**해설**: Network First 전략은 네트워크 요청을 먼저 시도하고, 성공하면 그 응답을 사용하고 캐시에도 저장합니다. 네트워크 요청이 실패하거나 시간이 초과되면 캐시에서 응답을 제공합니다. 이 전략은 항상 최신 데이터를 제공하면서도 오프라인 상태에서도 작동할 수 있도록 하는 데 유용합니다. Cache First는 캐시를 먼저 확인하는 전략이고, Cache Only는 항상 캐시에서만 응답을 제공하는 전략입니다.

### 문제 13
**문제**: 다음 중 Cache API를 사용하여 캐시에 응답을 추가하는 올바른 코드는?

**정답**: `cache.put(request, response)`

**해설**: cache.put(request, response) 메서드는 요청과 응답 쌍을 캐시에 추가합니다. cache.add(url) 메서드도 캐시에 항목을 추가하는 데 사용할 수 있지만, 이는 URL을 인자로 받아 해당 URL에 대한 요청을 수행하고 그 응답을 캐시에 저장합니다. cache.store()와 cache.save()는 실제 Cache API에 존재하지 않는 메서드입니다.

### 문제 14
**문제**: 캐시된 응답을 제공하면서 동시에 백그라운드에서 네트워크 요청을 통해 캐시를 업데이트하는 전략은?

**정답**: Stale-While-Revalidate

**해설**: Stale-While-Revalidate 전략은 캐시된 응답을 즉시 제공하면서 동시에 백그라운드에서 네트워크 요청을 통해 캐시를 업데이트합니다. 이 전략은 빠른 응답 시간과 최신 데이터 제공 사이의 균형을 맞추는 데 유용합니다. 사용자는 캐시된 응답을 통해 빠르게 콘텐츠를 볼 수 있고, 다음 요청 시에는 업데이트된 캐시를 사용할 수 있습니다.

## 서비스 워커 이벤트 처리

### 문제 15
**문제**: 서비스 워커에서 네트워크 요청을 가로채는 데 사용되는 이벤트는?

**정답**: fetch

**해설**: 서비스 워커에서 fetch 이벤트는 웹 페이지에서 리소스를 요청할 때 발생하며, 이를 통해 네트워크 요청을 가로채고 수정할 수 있습니다. 이 이벤트를 사용하여 캐시된 응답을 제공하거나, 네트워크 요청을 수정하거나, 완전히 새로운 응답을 생성할 수 있습니다. request, intercept, network는 서비스 워커에서 네트워크 요청을 가로채는 데 사용되는 이벤트가 아닙니다.

### 문제 16
**문제**: 푸시 알림을 구현하기 위해 서비스 워커에서 처리해야 하는 이벤트는?

**정답**: push

**해설**: 서비스 워커에서 push 이벤트는 서버에서 푸시 메시지가 도착했을 때 발생합니다. 이 이벤트를 처리하여 사용자에게 알림을 표시하거나 백그라운드에서 데이터를 업데이트할 수 있습니다. 웹 푸시 API와 함께 사용하여 사용자가 웹 페이지를 열지 않은 상태에서도 알림을 받을 수 있게 합니다. notification, message, alert는 푸시 알림을 구현하기 위한 서비스 워커 이벤트가 아닙니다.

### 문제 17
**문제**: 백그라운드 동기화를 위해 서비스 워커에서 사용하는 이벤트는?

**정답**: sync

**해설**: 서비스 워커에서 sync 이벤트는 백그라운드 동기화 API를 통해 등록된 동기화 작업이 실행될 때 발생합니다. 이 이벤트를 사용하여 오프라인 상태에서 실패한 네트워크 요청을 재시도하거나, 백그라운드에서 데이터를 동기화할 수 있습니다. 사용자가 오프라인 상태에서 작업을 수행한 후 온라인 상태가 되었을 때 자동으로 서버와 데이터를 동기화하는 데 유용합니다.

### 문제 18
**문제**: 서비스 워커에서 fetch 이벤트 처리 시 응답을 생성하는 방법으로 올바른 것을 모두 고르세요.

**정답**: 
- 캐시에서 응답 반환
- 네트워크 요청으로 응답 생성
- Response 객체 직접 생성
- Promise 반환

**해설**: 
- 캐시에서 응답 반환: caches.match()를 사용하여 캐시에서 응답을 찾아 반환할 수 있습니다.
- 네트워크 요청으로 응답 생성: fetch()를 사용하여 네트워크 요청을 수행하고 그 응답을 반환할 수 있습니다.
- Response 객체 직접 생성: new Response()를 사용하여 직접 응답 객체를 생성할 수 있습니다.
- DOM 요소 반환: 서비스 워커는 DOM에 접근할 수 없으므로 DOM 요소를 직접 반환할 수 없습니다.
- Promise 반환: fetch 이벤트 핸들러에서는 Promise를 반환하여 비동기적으로 응답을 생성할 수 있습니다.

## 프로그레시브 웹 앱(PWA)

### 문제 19
**문제**: PWA의 필수 구성 요소가 아닌 것은?

**정답**: 서버 사이드 렌더링

**해설**: 서버 사이드 렌더링(SSR)은 PWA의 필수 구성 요소가 아닙니다. PWA의 필수 구성 요소는 서비스 워커, 매니페스트 파일, HTTPS입니다. 서비스 워커는 오프라인 기능과 백그라운드 동기화를 제공하고, 매니페스트 파일은 홈 화면 설치 기능을 제공하며, HTTPS는 보안을 위해 필요합니다. SSR은 초기 로딩 성능을 향상시키는 데 도움이 될 수 있지만, PWA의 필수 요소는 아닙니다.

### 문제 20
**문제**: 웹 앱 매니페스트 파일의 확장자는?

**정답**: .json

**해설**: 웹 앱 매니페스트 파일은 일반적으로 .json 확장자를 사용합니다. 매니페스트 파일은 JSON 형식으로 작성되며, 웹 앱의 이름, 아이콘, 시작 URL, 표시 모드 등의 정보를 포함합니다. .webmanifest 확장자도 사용할 수 있지만, .json이 더 일반적입니다. .manifest와 .pwa는 웹 앱 매니페스트 파일의 표준 확장자가 아닙니다.

### 문제 21
**문제**: 웹 앱 매니페스트에서 앱의 표시 모드를 지정하는 속성은?

**정답**: display

**해설**: 웹 앱 매니페스트에서 display 속성은 앱이 사용자에게 어떻게 표시될지를 지정합니다. 가능한 값으로는 "fullscreen", "standalone", "minimal-ui", "browser" 등이 있습니다. "standalone" 모드는 브라우저 UI 없이 앱처럼 표시되는 가장 일반적인 설정입니다. view, mode, appearance는 웹 앱 매니페스트의 표준 속성이 아닙니다.

### 문제 22
**문제**: 오프라인 상태를 감지하는 JavaScript 이벤트는?

**정답**: window.addEventListener('offline', ...)

**해설**: 오프라인 상태를 감지하는 표준 JavaScript 이벤트는 window 객체의 'offline' 이벤트입니다. 이 이벤트는 브라우저가 오프라인 상태가 되었을 때 발생합니다. 비슷하게, 'online' 이벤트는 브라우저가 온라인 상태가 되었을 때 발생합니다. window.onoffline 속성을 통해 이벤트 핸들러를 설정할 수도 있지만, addEventListener 메서드를 사용하는 것이 더 현대적인 접근 방식입니다.

## 서비스 워커 고급 주제

### 문제 23
**문제**: 서비스 워커에서 중요한 리소스를 미리 캐싱하는 기법은?

**정답**: 프리캐싱

**해설**: 프리캐싱은 서비스 워커 설치 단계에서 중요한 리소스를 미리 캐시에 저장하는 기법입니다. 이를 통해 사용자가 오프라인 상태가 되더라도 웹 앱의 핵심 기능을 사용할 수 있게 합니다. 프리캐싱은 일반적으로 서비스 워커의 install 이벤트 핸들러 내에서 구현됩니다. 런타임 캐싱은 사용자가 리소스를 요청할 때 캐싱하는 방식이며, 동적 캐싱과 지연 캐싱은 표준 용어가 아닙니다.

### 문제 24
**문제**: 서비스 워커의 보안 관련 특성으로 올바른 것을 모두 고르세요.

**정답**: 
- HTTPS 필수 요구사항
- 스코프 제한
- 샌드박스 환경에서 실행
- 동일 출처 정책 적용

**해설**: 
- HTTPS 필수 요구사항: 서비스 워커는 보안상의 이유로 HTTPS 환경에서만 작동합니다(개발 환경 제외).
- 스코프 제한: 서비스 워커는 등록된 스코프 내의 페이지만 제어할 수 있습니다.
- 샌드박스 환경에서 실행: 서비스 워커는 격리된 환경에서 실행되어 DOM에 직접 접근할 수 없습니다.
- 사용자 인증 필수: 이는 서비스 워커의 표준 보안 특성이 아닙니다. 서비스 워커는 사용자 인증 없이도 사용할 수 있습니다.
- 동일 출처 정책 적용: 서비스 워커는 동일 출처 정책을 따르며, 기본적으로 다른 출처의 리소스에 대한 요청을 수정할 수 없습니다.

### 문제 25
**문제**: 서비스 워커 성능 최적화 방법으로 올바르지 않은 것은?

**정답**: 모든 네트워크 요청 차단하기

**해설**: 모든 네트워크 요청을 차단하는 것은 서비스 워커 성능 최적화 방법으로 올바르지 않습니다. 이는 사용자 경험을 저하시키고 웹 앱의 기능을 제한할 수 있습니다. 올바른 성능 최적화 방법으로는 필요한 리소스만 캐싱하기, 적절한 캐싱 전략 선택하기, 캐시 만료 정책 설정하기 등이 있습니다. 서비스 워커는 네트워크 요청을 선택적으로 가로채고 최적화하는 데 사용되어야 합니다.
