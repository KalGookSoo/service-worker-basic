# 정답 및 해설

이 문서는 각 장의 확인 문제에 대한 정답과 해설을 제공합니다.

## 목차
- [Chapter 01 서비스 워커 소개](#chapter-01-서비스-워커-소개)
  - [01-1 서비스 워커란 무엇인가](#01-1-서비스-워커란-무엇인가)
  - [01-2 서비스 워커의 특징](#01-2-서비스-워커의-특징)
  - [01-3 서비스 워커 지원 환경](#01-3-서비스-워커-지원-환경)
- [Chapter 02 서비스 워커 생명주기](#chapter-02-서비스-워커-생명주기)
  - [02-1 서비스 워커 등록과 설치](#02-1-서비스-워커-등록과-설치)
  - [02-2 서비스 워커 활성화와 업데이트](#02-2-서비스-워커-활성화와-업데이트)
  - [02-3 서비스 워커 상태 관리](#02-3-서비스-워커-상태-관리)
- [Chapter 03 서비스 워커와 캐싱](#chapter-03-서비스-워커와-캐싱)
  - [03-1 Cache API 기초](#03-1-cache-api-기초)

## Chapter 01 서비스 워커 소개

### 01-1 서비스 워커란 무엇인가

#### 문제 1
**문제**: 서비스 워커의 주요 역할이 아닌 것은?

**정답**: DOM 직접 조작

**해설**: 서비스 워커는 웹 페이지와 별도로 백그라운드에서 실행되는 JavaScript 워커로, DOM에 직접 접근할 수 없습니다. 서비스 워커는 네트워크 요청 가로채기, 리소스 캐싱, 푸시 알림 처리와 같은 기능을 수행할 수 있지만, DOM 조작은 메인 스레드에서만 가능합니다. 서비스 워커가 DOM과 상호작용하려면 postMessage() 메서드를 통해 메인 스레드와 통신해야 합니다.

#### 문제 2
**문제**: 서비스 워커와 웹 워커의 차이점으로 올바른 것은?

**정답**: 서비스 워커는 네트워크 요청을 가로챌 수 있지만, 웹 워커는 그렇지 않다

**해설**: 서비스 워커는 네트워크 요청을 가로채고 수정할 수 있는 기능을 가지고 있어 오프라인 지원, 캐싱 전략 구현 등이 가능합니다. 반면, 웹 워커는 CPU 집약적인 작업을 메인 스레드와 별도로 처리하기 위한 목적으로 설계되었으며, 네트워크 요청을 가로채는 기능은 없습니다. 또한 서비스 워커는 페이지와 독립적인 생명주기를 가지며 여러 탭과 창에 걸쳐 작동할 수 있지만, 웹 워커는 생성한 페이지에 종속되어 있습니다.

#### 문제 3
**문제**: 웹 개발자가 서비스 워커를 사용하는 주요 이유로 올바른 것을 모두 고르세요.

**정답**: 오프라인 웹 경험 제공, 네트워크 요청 최적화, 푸시 알림 구현

**해설**: 
- 오프라인 웹 경험 제공: 서비스 워커는 리소스를 캐싱하여 인터넷 연결이 없거나 불안정한 상황에서도 웹 애플리케이션이 작동할 수 있게 합니다.
- 네트워크 요청 최적화: 서비스 워커는 네트워크 요청을 가로채고 캐시된 응답을 제공하거나 네트워크 요청을 수정하여 성능을 최적화할 수 있습니다.
- 푸시 알림 구현: 서비스 워커는 웹 푸시 API와 함께 사용하여 사용자에게 푸시 알림을 보낼 수 있습니다.
- 서버 부하 감소: 이는 서비스 워커의 직접적인 목적이라기보다는 캐싱과 네트워크 최적화의 부수적인 효과입니다.
- DOM 직접 조작: 서비스 워커는 DOM에 직접 접근할 수 없으므로 이는 올바르지 않습니다.

### 01-2 서비스 워커의 특징

#### 문제 1
**문제**: 서비스 워커가 메인 스레드와 별도로 실행되는 이유로 가장 적절한 것은?

**정답**: UI 블로킹을 방지하고 백그라운드 작업을 수행하기 위해

**해설**: 서비스 워커는 메인 스레드와 별도의 워커 스레드에서 실행됩니다. 이는 UI 블로킹을 방지하고 백그라운드 작업을 수행할 수 있게 하는 중요한 특성입니다. 메인 스레드는 DOM 조작과 사용자 인터페이스 처리를 담당하는데, 서비스 워커가 별도의 스레드에서 실행됨으로써 네트워크 요청 처리, 캐싱, 푸시 알림 등의 작업이 메인 스레드를 차단하지 않고 백그라운드에서 효율적으로 수행될 수 있습니다.

#### 문제 2
**문제**: 서비스 워커의 프록시 역할에 대한 설명으로 올바르지 않은 것은?

**정답**: 서버의 부하를 직접 모니터링할 수 있다

**해설**: 서비스 워커는 웹 애플리케이션과 네트워크 사이에서 프록시 역할을 하며, 네트워크 요청을 가로채고 수정할 수 있고, 다양한 캐싱 전략을 구현할 수 있으며, 오프라인 상태에서도 캐시된 응답을 제공할 수 있습니다. 그러나 서비스 워커는 클라이언트 측 기술로, 서버의 부하를 직접 모니터링하는 기능은 없습니다. 서버 부하 모니터링은 서버 측 도구나 별도의 모니터링 서비스를 통해 수행해야 합니다.

#### 문제 3
**문제**: 서비스 워커에서 사용되는 이벤트가 아닌 것은?

**정답**: click

**해설**: 서비스 워커는 install, activate, fetch, push, sync, message 등의 이벤트를 처리할 수 있습니다. 그러나 click 이벤트는 DOM 이벤트로, 서비스 워커에서 직접 처리할 수 없습니다. 서비스 워커는 DOM에 접근할 수 없기 때문에 click과 같은 사용자 인터페이스 이벤트는 메인 스레드에서 처리되어야 합니다. 서비스 워커가 이러한 이벤트에 반응하려면 메인 스레드에서 postMessage()를 통해 메시지를 전송해야 합니다.

#### 문제 4
**문제**: 서비스 워커의 비동기적 특성에 관한 설명으로 올바른 것은?

**정답**: 서비스 워커는 Promise 기반의 API를 주로 사용한다

**해설**: 서비스 워커는 본질적으로 비동기적인 특성을 가지고 있으며, Promise 기반의 API를 주로 사용합니다. 서비스 워커 등록(register()), 캐시 작업(caches.open(), cache.add() 등), 네트워크 요청(fetch()) 등 대부분의 서비스 워커 API는 Promise를 반환합니다. 이러한 비동기적 특성은 작업이 완료될 때까지 기다리는 동안 다른 작업을 수행할 수 있게 하여 성능을 향상시키고 효율적인 리소스 사용을 가능하게 합니다.

#### 문제 5
**문제**: 서비스 워커가 HTTPS를 요구하는 이유로 가장 적절한 것은?

**정답**: 보안상의 이유로 중간자 공격을 방지하기 위해

**해설**: 서비스 워커는 네트워크 요청을 가로채고 수정할 수 있는 강력한 기능을 가지고 있기 때문에, 보안상의 이유로 HTTPS 환경에서만 작동하도록 설계되었습니다. HTTPS는 통신 내용이 제3자에 의해 가로채지거나 변조되는 중간자 공격을 방지하고, 웹사이트의 신원을 확인할 수 있게 합니다. 이를 통해 서비스 워커의 강력한 기능이 악의적인 목적으로 사용되는 것을 방지하고, 사용자의 데이터와 프라이버시를 보호할 수 있습니다. 개발 목적으로는 localhost나 127.0.0.1과 같은 로컬 환경에서는 HTTPS 없이도 서비스 워커를 사용할 수 있습니다.

### 01-3 서비스 워커 지원 환경

#### 문제 1
**문제**: 서비스 워커 지원 여부를 확인하는 올바른 JavaScript 코드는?

**정답**: if ('serviceWorker' in navigator) { ... }

**해설**: 서비스 워커 지원 여부를 확인하는 표준적인 방법은 'serviceWorker' 속성이 navigator 객체에 존재하는지 확인하는 것입니다. 이 코드는 브라우저가 서비스 워커를 지원하는 경우에만 조건문 내부의 코드를 실행합니다. 다른 옵션들은 유효한 JavaScript 구문이 아니거나(browser.supportsServiceWorker()), 서비스 워커 지원 여부를 올바르게 확인하지 못합니다(window.serviceWorker, document.serviceWorker). 이러한 기능 감지 패턴은 점진적 향상 기법을 구현할 때 중요한 역할을 합니다.

#### 문제 2
**문제**: 서비스 워커를 지원하지 않는 브라우저에서 사용할 수 있는 대체 기술이 아닌 것은?

**정답**: WebSocket API

**해설**: WebSocket API는 클라이언트와 서버 간의 양방향 통신 채널을 제공하는 기술로, 서비스 워커의 대체 기술이라기보다는 다른 목적을 가진 별개의 웹 API입니다. IndexedDB, LocalStorage, SessionStorage는 모두 클라이언트 측 데이터 저장 메커니즘으로, 서비스 워커의 캐싱 기능을 부분적으로 대체할 수 있습니다. 특히 IndexedDB는 대용량 구조화된 데이터를 저장하는 데 사용될 수 있으며, LocalStorage와 SessionStorage는 간단한 키-값 데이터를 저장하는 데 사용될 수 있습니다.

#### 문제 3
**문제**: 서비스 워커를 사용할 때 권장되는 개발 접근 방식은?

**정답**: 점진적 향상 기법 적용하기

**해설**: 점진적 향상(Progressive Enhancement) 기법은 모든 사용자에게 기본적인 기능을 제공하고, 브라우저가 지원하는 경우에만 추가 기능을 활성화하는 접근 방식입니다. 이 방식을 사용하면 서비스 워커를 지원하지 않는 브라우저에서도 웹 애플리케이션의 핵심 기능이 작동하며, 서비스 워커를 지원하는 브라우저에서는 다음과 같은 향상된 기능을 제공할 수 있습니다:

1. **오프라인 작동**: 인터넷 연결이 없어도 이전에 방문한 페이지와 리소스를 볼 수 있습니다.
2. **성능 향상**: 이미지, 스크립트, 스타일시트 등을 캐시하여 로딩 속도를 개선합니다.
3. **네트워크 복원력**: 불안정한 네트워크 환경에서도 캐시된 콘텐츠를 제공하여 사용자 경험을 유지합니다.
4. **오프라인 대체 콘텐츠**: 네트워크 연결이 없을 때 오프라인 페이지나 대체 이미지를 제공합니다.
5. **백그라운드 동기화**: 오프라인 상태에서 사용자 작업을 저장하고, 온라인 상태가 되면 자동으로 동기화합니다.
6. **푸시 알림**: 웹 애플리케이션이 닫혀 있어도 사용자에게 알림을 보낼 수 있습니다.

예를 들어, 이미지 갤러리 웹 애플리케이션에서는 기본적으로 모든 브라우저에서 이미지를 로드하고 표시하는 기능을 제공하고, 서비스 워커를 지원하는 브라우저에서는 이미지를 캐시하여 오프라인에서도 볼 수 있게 하거나, 네트워크 오류 시 대체 이미지를 제공하는 등의 향상된 기능을 추가할 수 있습니다.

서비스 워커를 지원하는 브라우저만 타겟팅하는 것은 많은 사용자를 배제할 수 있으며, 모든 기능을 폴리필로 구현하는 것은 서비스 워커의 특성상 완전히 불가능합니다. AppCache는 현재 deprecated된 기술로, 서비스 워커와 함께 사용하는 것은 권장되지 않습니다.

## Chapter 02 서비스 워커 생명주기

### 02-1 서비스 워커 등록과 설치

#### 문제 1
**문제**: 서비스 워커 등록 시 사용하는 올바른 메서드는?

**정답**: navigator.serviceWorker.register()

**해설**: 서비스 워커를 등록하기 위해서는 `navigator.serviceWorker.register()` 메서드를 사용합니다. 이 메서드는 서비스 워커 스크립트의 URL을 매개변수로 받고, Promise를 반환합니다. 다른 옵션들은 존재하지 않는 메서드이거나(navigator.serviceWorker.create(), document.serviceWorker.install()), 잘못된 객체에서 메서드를 호출하는 경우(window.serviceWorker.register())입니다. 서비스 워커 API는 navigator 객체의 serviceWorker 속성을 통해 접근해야 합니다.

#### 문제 2
**문제**: 서비스 워커의 기본 스코프를 결정하는 요소는?

**정답**: 서비스 워커 스크립트 파일의 위치

**해설**: 서비스 워커의 기본 스코프는 서비스 워커 스크립트 파일이 위치한 디렉토리와 그 하위 디렉토리로 제한됩니다. 예를 들어, 서비스 워커 파일이 `/js/service-worker.js`에 위치한다면, 기본 스코프는 `/js/`가 되어 `/js/` 경로와 그 하위 경로의 페이지만 제어할 수 있습니다. 이는 보안상의 이유로 서비스 워커가 자신이 위치한 디렉토리보다 상위 경로의 리소스를 제어하지 못하도록 하기 위함입니다. 스코프를 명시적으로 지정하려면 `register()` 메서드의 두 번째 매개변수로 옵션 객체를 전달하여 `scope` 속성을 설정할 수 있지만, 이 경우에도 서비스 워커 파일 위치보다 상위 디렉토리로 스코프를 설정할 수는 없습니다.

#### 문제 3
**문제**: 서비스 워커 설치 과정에서 비동기 작업이 완료될 때까지 설치를 연장하기 위해 사용하는 메서드는?

**정답**: event.waitUntil()

**해설**: `event.waitUntil()` 메서드는 서비스 워커의 설치 이벤트 핸들러에서 비동기 작업이 완료될 때까지 설치 과정을 연장하는 데 사용됩니다. 이 메서드는 Promise를 인자로 받아 해당 Promise가 해결될 때까지 설치 단계를 연장합니다. 주로 캐시 초기화와 필수 리소스 캐싱과 같은 비동기 작업이 완료될 때까지 서비스 워커의 설치가 완료되지 않도록 하는 데 사용됩니다. 다른 옵션들은 존재하지 않는 메서드입니다. 설치 과정에서 `waitUntil()`을 사용하지 않으면, 비동기 작업이 완료되기 전에 설치가 완료될 수 있어 캐싱이 제대로 이루어지지 않을 수 있습니다.

#### 문제 4
**문제**: 서비스 워커가 설치된 후 대기 단계를 건너뛰고 즉시 활성화하기 위해 사용하는 메서드는?

**정답**: self.skipWaiting()

**해설**: `self.skipWaiting()` 메서드는 새로 설치된 서비스 워커가 대기 단계를 건너뛰고 즉시 활성화되도록 하는 데 사용됩니다. 일반적으로 서비스 워커는 설치된 후 기존 서비스 워커가 제어하는 페이지가 모두 닫힐 때까지 대기 상태에 머무르지만, `skipWaiting()`을 호출하면 이 대기 과정을 건너뛰고 즉시 활성화됩니다. 이는 중요한 업데이트를 즉시 적용해야 할 때 유용하지만, 페이지가 로드된 후 서비스 워커가 변경되면 예상치 못한 동작이 발생할 수 있으므로 주의해야 합니다. 다른 옵션들은 존재하지 않는 메서드이거나(self.activate(), registration.activate()), 잘못된 객체에서 메서드를 호출하는 경우(event.skipWaiting())입니다.

#### 문제 5
**문제**: 다음 중 서비스 워커 등록 과정에서 발생할 수 있는 문제가 아닌 것은?

**정답**: DOM 요소에 직접 접근 시도

**해설**: 서비스 워커 등록 과정은 웹 페이지의 JavaScript 코드에서 이루어지므로, DOM 요소에 직접 접근하는 것은 등록 과정과 관련이 없습니다. DOM 접근 문제는 서비스 워커 스크립트 내부에서 발생할 수 있는 문제로, 서비스 워커는 DOM에 직접 접근할 수 없기 때문에 DOM 조작을 시도하면 오류가 발생합니다. 반면, HTTP 환경에서 서비스 워커 등록 시도(HTTPS가 필요), 서비스 워커 스크립트 파일 경로 오류, 잘못된 스코프 설정은 모두 서비스 워커 등록 과정에서 실제로 발생할 수 있는 문제입니다. 서비스 워커는 보안상의 이유로 HTTPS 환경에서만 작동하며(localhost는 예외), 스크립트 파일 경로가 올바르지 않거나 스코프 설정이 잘못되면 등록이 실패할 수 있습니다.

### 02-2 서비스 워커 활성화와 업데이트

#### 문제 1
**문제**: 서비스 워커의 활성화 이벤트에서 주로 수행하는 작업은?

**정답**: 오래된 캐시 정리

**해설**: 서비스 워커의 `activate` 이벤트 핸들러에서는 주로 오래된 캐시를 정리하는 작업을 수행합니다. 새 버전의 서비스 워커가 활성화될 때, 이전 버전에서 사용하던 캐시를 삭제하거나 업데이트하여 스토리지 공간을 효율적으로 관리하고 오래된 리소스가 사용되지 않도록 합니다. 이 외에도 데이터베이스 마이그레이션이나 새 버전의 서비스 워커에 필요한 설정 초기화 작업을 수행할 수 있습니다. 반면, 필수 리소스 캐싱은 주로 `install` 이벤트에서 수행하고, 네트워크 요청 가로채기는 `fetch` 이벤트에서, 푸시 알림 설정은 `push` 이벤트에서 처리합니다.

#### 문제 2
**문제**: 활성화된 서비스 워커가 이미 열려있는 페이지를 즉시 제어하도록 하는 메서드는?

**정답**: clients.claim()

**해설**: `clients.claim()` 메서드는 활성화된 서비스 워커가 이미 열려있는 페이지를 즉시 제어할 수 있게 해줍니다. 기본적으로 서비스 워커는 활성화된 후에도 이미 로드된 페이지는 제어하지 않고 새로 열리는 페이지만 제어하게 됩니다. `clients.claim()`을 호출하면 활성화된 서비스 워커가 즉시 모든 열린 페이지를 제어할 수 있게 되어, 중요한 업데이트를 즉시 적용하거나 개발 중에 서비스 워커 변경사항을 빠르게 테스트할 수 있습니다. 다른 옵션들은 존재하지 않는 메서드이거나(self.activate(), self.control()), 잘못된 객체에서 메서드를 호출하는 경우(navigator.serviceWorker.claim())입니다.

#### 문제 3
**문제**: 서비스 워커 스크립트가 업데이트되었다고 브라우저가 인식하는 조건은?

**정답**: 서비스 워커 파일의 내용이 1바이트라도 변경된 경우

**해설**: 브라우저는 서비스 워커 스크립트를 바이트 단위로 비교하여 변경 사항이 있는지 확인합니다. 스크립트 파일의 내용이 1바이트라도 변경되었다면, 브라우저는 이를 새 버전으로 간주하고 업데이트 과정을 시작합니다. 파일의 수정 날짜나 이름 변경은 브라우저가 업데이트를 감지하는 기준이 아니며, 파일 크기의 변화 비율도 관련이 없습니다. 이러한 바이트 단위 비교 방식 때문에, 서비스 워커 코드에 주석 하나만 추가하거나 공백 하나만 변경해도 브라우저는 이를 새 버전으로 인식합니다. 이 특성을 활용하여 서비스 워커를 강제로 업데이트할 수도 있습니다.

#### 문제 4
**문제**: 서비스 워커 업데이트를 수동으로 트리거하는 올바른 메서드는?

**정답**: registration.update()

**해설**: 서비스 워커 업데이트를 수동으로 트리거하려면 `ServiceWorkerRegistration` 객체의 `update()` 메서드를 사용합니다. 이 메서드는 서비스 워커 스크립트를 다시 다운로드하고 변경 사항이 있는지 확인합니다. 일반적으로 `navigator.serviceWorker.ready.then(registration => registration.update())` 형태로 사용됩니다. 이 방법은 중요한 업데이트를 즉시 적용해야 할 때나 사용자에게 업데이트 알림을 표시하고 싶을 때 유용합니다. 다른 옵션들은 존재하지 않는 메서드입니다(navigator.serviceWorker.update(), self.update(), serviceWorker.checkForUpdates()).

#### 문제 5
**문제**: 다음 중 서비스 워커 버전 관리 전략으로 적절하지 않은 것은? (복수 응답)

**정답**: 서비스 워커 파일 이름에 버전 번호 포함, localStorage에 버전 정보 저장

**해설**: 
- 서비스 워커 파일 이름에 버전 번호를 포함하는 방법(예: service-worker-v2.js)은 등록 코드도 함께 업데이트해야 하므로 효율적인 버전 관리 전략이 아닙니다. 이는 서비스 워커 등록 코드가 변경될 때마다 사용자가 페이지를 새로고침해야 하므로 원활한 업데이트가 어렵습니다.
- localStorage에 버전 정보를 저장하는 방법은 서비스 워커의 버전 관리에 적합하지 않습니다. localStorage는 웹 페이지의 JavaScript에서 접근할 수 있지만, 서비스 워커는 독립적인 실행 컨텍스트를 가지므로 localStorage에 저장된 정보를 직접 활용하기 어렵습니다.
- 반면, 캐시 이름에 버전 번호를 포함하는 방법(예: app-cache-v1.2.3)은 서비스 워커 내에서 캐시를 효과적으로 관리할 수 있게 해줍니다.
- importScripts()를 사용하여 버전 정보가 포함된 별도의 파일을 임포트하는 방법은 서비스 워커 파일을 변경하지 않고도 버전을 업데이트할 수 있어 효율적입니다.
- 서비스 워커 코드에 버전 상수를 정의하는 방법(예: const VERSION = 'v1.2.3')도 간단하고 직관적인 버전 관리 방법입니다.

### 02-3 서비스 워커 상태 관리

#### 문제 1
**문제**: 서비스 워커의 상태를 확인하기 위해 사용하는 객체는?

**정답**: ServiceWorkerRegistration

**해설**: `ServiceWorkerRegistration` 객체는 서비스 워커 등록에 관한 정보를 제공하며, 서비스 워커의 상태를 확인하고 관리하는 데 사용됩니다. 이 객체는 `installing`, `waiting`, `active` 등의 속성을 통해 서비스 워커의 현재 상태를 확인할 수 있으며, `update()`, `unregister()` 등의 메서드를 제공하여 서비스 워커를 관리할 수 있게 합니다. `ServiceWorkerController`와 `ServiceWorkerState`, `ServiceWorkerManager`는 존재하지 않는 객체입니다.

#### 문제 2
**문제**: 서비스 워커의 상태 중 '설치는 완료되었지만 아직 활성화되지 않은 상태'를 나타내는 것은?

**정답**: installed

**해설**: 서비스 워커의 상태 중 `installed`(또는 `waiting`이라고도 함)는 서비스 워커의 설치가 완료되었지만 아직 활성화되지 않은 상태를 나타냅니다. 이 상태에서 서비스 워커는 이전 서비스 워커가 더 이상 사용되지 않을 때까지 대기하거나, `skipWaiting()` 메서드가 호출될 때까지 대기합니다. `installing`은 설치 중인 상태, `activating`은 활성화 중인 상태, `activated`는 활성화가 완료된 상태를 나타냅니다.

#### 문제 3
**문제**: 서비스 워커 등록을 해제하는 메서드는?

**정답**: registration.unregister()

**해설**: 서비스 워커 등록을 해제하려면 `ServiceWorkerRegistration` 객체의 `unregister()` 메서드를 사용합니다. 이 메서드는 서비스 워커 등록을 해제하고 Promise를 반환합니다. 일반적으로 `navigator.serviceWorker.getRegistration().then(registration => registration.unregister())` 형태로 사용됩니다. `registration.remove()`, `registration.delete()`, `registration.deactivate()`는 존재하지 않는 메서드입니다.

#### 문제 4
**문제**: 서비스 워커의 상태 변경을 감지하는 이벤트는?

**정답**: statechange

**해설**: 서비스 워커의 상태 변경은 `statechange` 이벤트를 통해 감지할 수 있습니다. 이 이벤트는 서비스 워커의 상태가 변경될 때마다 발생하며, 이벤트 핸들러에서 `event.target.state`를 통해 새로운 상태를 확인할 수 있습니다. 주로 `serviceWorker.addEventListener('statechange', event => { ... })` 형태로 사용됩니다. `statuschange`, `change`, `update`는 서비스 워커의 상태 변경과 관련된 이벤트가 아닙니다.

#### 문제 5
**문제**: 다음 중 서비스 워커 상태 관리와 관련된 올바른 설명은? (복수 응답)

**정답**: 새로운 서비스 워커가 설치되면 `updatefound` 이벤트가 발생한다, 활성화된 서비스 워커가 변경되면 `controllerchange` 이벤트가 발생한다, `getRegistrations()` 메서드를 사용하여 모든 서비스 워커 등록을 가져올 수 있다

**해설**: 
- 새로운 서비스 워커가 설치되면 `updatefound` 이벤트가 발생합니다. 이 이벤트는 `ServiceWorkerRegistration` 객체에서 발생하며, 새로운 서비스 워커가 발견되고 설치 과정이 시작될 때 트리거됩니다.
- 활성화된 서비스 워커가 변경되면 `controllerchange` 이벤트가 발생합니다. 이 이벤트는 `navigator.serviceWorker` 객체에서 발생하며, 페이지를 제어하는 서비스 워커가 변경될 때 트리거됩니다.
- `getRegistrations()` 메서드를 사용하여 모든 서비스 워커 등록을 가져올 수 있습니다. 이 메서드는 `navigator.serviceWorker` 객체에서 제공되며, 현재 페이지의 출처에 등록된 모든 서비스 워커 등록을 Promise로 반환합니다.
- 서비스 워커의 상태는 `navigator.serviceWorker.state`로 직접 확인할 수 없습니다. 서비스 워커의 상태는 `ServiceWorker` 객체의 `state` 속성을 통해 확인해야 합니다.
- 서비스 워커 등록을 해제하면 관련 캐시는 자동으로 삭제되지 않습니다. 캐시를 정리하려면 별도로 `caches.delete()` 메서드를 호출해야 합니다.

## Chapter 03 서비스 워커와 캐싱

### 03-1 Cache API 기초

#### 문제 1
**문제**: Cache API의 주요 목적은 무엇인가요?

**정답**: HTTP 요청과 응답 쌍의 저장 및 관리

**해설**: Cache API의 주요 목적은 HTTP 요청과 응답 쌍을 저장하고 관리하는 것입니다. 이를 통해 웹 애플리케이션은 네트워크 연결 없이도 이전에 캐시된 리소스에 접근할 수 있어 오프라인 기능과 성능 향상을 제공할 수 있습니다. Cache API는 서비스 워커와 함께 사용되어 네트워크 요청을 가로채고 캐시된 응답을 제공하는 데 중요한 역할을 합니다. 브라우저 히스토리 관리, 사용자 인증 정보 저장, 웹 페이지 성능 측정은 Cache API의 주요 목적이 아닙니다.

#### 문제 2
**문제**: 캐시에 응답을 저장하기 위해 사용하는 메서드가 아닌 것은?

**정답**: cache.store()

**해설**: Cache API에서 응답을 저장하기 위해 사용하는 메서드는 `cache.put()`, `cache.add()`, `cache.addAll()`입니다. `cache.store()`는 존재하지 않는 메서드입니다. `cache.put()`은 요청-응답 쌍을 직접 저장하고, `cache.add()`는 URL을 가져와서 응답을 캐시에 저장하며, `cache.addAll()`은 URL 배열을 가져와서 모든 응답을 캐시에 저장합니다. 이러한 메서드들은 모두 Promise를 반환하여 비동기 작업을 처리합니다.

#### 문제 3
**문제**: 캐시에서 응답을 검색하는 메서드는?

**정답**: cache.match()

**해설**: 캐시에서 응답을 검색하기 위해 사용하는 메서드는 `cache.match()`입니다. 이 메서드는 요청 객체나 URL 문자열을 인자로 받아 해당 요청에 대한 캐시된 응답을 찾습니다. 일치하는 응답이 없으면 `undefined`를 반환합니다. 또한 `caches.match()`를 사용하여 모든 캐시에서 응답을 검색할 수도 있습니다. `cache.get()`, `cache.find()`, `cache.retrieve()`는 Cache API에 존재하지 않는 메서드입니다.

#### 문제 4
**문제**: 서비스 워커의 어떤 이벤트에서 주로 오래된 캐시를 정리하나요?

**정답**: activate

**해설**: 서비스 워커의 `activate` 이벤트에서 주로 오래된 캐시를 정리합니다. 서비스 워커가 업데이트되어 새 버전이 활성화될 때, 이전 버전에서 사용하던 캐시를 삭제하거나 업데이트하는 작업을 `activate` 이벤트 핸들러에서 수행합니다. 이는 스토리지 공간을 효율적으로 관리하고 오래된 리소스가 사용되지 않도록 하기 위함입니다. `install` 이벤트는 주로 필수 리소스를 캐싱하는 데 사용되고, `fetch` 이벤트는 네트워크 요청을 가로채는 데 사용되며, `message` 이벤트는 웹 페이지와 서비스 워커 간의 통신에 사용됩니다.

#### 문제 5
**문제**: Cache API와 HTTP 캐시의 차이점으로 올바른 것은? (복수 응답)

**정답**: Cache API는 프로그래밍 방식으로 완전히 제어할 수 있다, HTTP 캐시는 HTTP 헤더에 의해 제어된다, Cache API는 오프라인 사용을 위해 설계되었다

**해설**: 
- Cache API는 프로그래밍 방식으로 완전히 제어할 수 있습니다. 개발자는 JavaScript를 통해 캐시의 생성, 읽기, 업데이트, 삭제를 직접 제어할 수 있습니다.
- HTTP 캐시는 HTTP 헤더에 의해 제어됩니다. Cache-Control, Expires, ETag 등의 HTTP 헤더를 통해 브라우저의 캐싱 동작을 지시합니다.
- Cache API는 오프라인 사용을 위해 설계되었습니다. 서비스 워커와 함께 사용하여 네트워크 연결 없이도 웹 애플리케이션이 작동할 수 있게 합니다.
- HTTP 캐시는 JavaScript로 직접 접근할 수 없습니다. 브라우저에 의해 자동으로 관리되며, 개발자가 직접 조작할 수 없습니다.
- Cache API는 서비스 워커 없이도 사용할 수 있지만, 주로 서비스 워커와 함께 사용하여 오프라인 기능을 구현합니다. 서비스 워커 없이 사용할 경우 제한된 기능만 사용할 수 있습니다.

