# 정답 및 해설

이 문서는 각 장의 확인 문제에 대한 정답과 해설을 제공합니다.

## 목차
- [Chapter 01 서비스 워커 소개](#chapter-01-서비스-워커-소개)
  - [01-1 서비스 워커란 무엇인가](#01-1-서비스-워커란-무엇인가)
  - [01-2 서비스 워커의 특징](#01-2-서비스-워커의-특징)
  - [01-3 서비스 워커 지원 환경](#01-3-서비스-워커-지원-환경)
- [Chapter 02 서비스 워커 생명주기](#chapter-02-서비스-워커-생명주기)
  - [02-1 서비스 워커 등록과 설치](#02-1-서비스-워커-등록과-설치)
  - [02-2 서비스 워커 활성화와 업데이트](#02-2-서비스-워커-활성화와-업데이트)
  - [02-3 서비스 워커 상태 관리](#02-3-서비스-워커-상태-관리)
- [Chapter 03 서비스 워커와 캐싱](#chapter-03-서비스-워커와-캐싱)
  - [03-1 Cache API 기초](#03-1-cache-api-기초)
  - [03-2 캐싱 전략](#03-2-캐싱-전략)
  - [03-3 동적 콘텐츠 캐싱](#03-3-동적-콘텐츠-캐싱)
- [Chapter 04 서비스 워커 이벤트 처리](#chapter-04-서비스-워커-이벤트-처리)
  - [04-1 Fetch 이벤트](#04-1-fetch-이벤트)
  - [04-2 Push 이벤트와 알림](#04-2-push-이벤트와-알림)
  - [04-3 백그라운드 동기화](#04-3-백그라운드-동기화)
- [Chapter 05 프로그레시브 웹 앱(PWA)](#chapter-05-프로그레시브-웹-앱pwa)
  - [05-1 PWA 개요](#05-1-pwa-개요)

## Chapter 01 서비스 워커 소개

### 01-1 서비스 워커란 무엇인가

#### 문제 1
**문제**: 서비스 워커의 주요 역할이 아닌 것은?

**정답**: DOM 직접 조작

**해설**: 서비스 워커는 웹 페이지와 별도로 백그라운드에서 실행되는 JavaScript 워커로, DOM에 직접 접근할 수 없습니다. 서비스 워커는 네트워크 요청 가로채기, 리소스 캐싱, 푸시 알림 처리와 같은 기능을 수행할 수 있지만, DOM 조작은 메인 스레드에서만 가능합니다. 서비스 워커가 DOM과 상호작용하려면 postMessage() 메서드를 통해 메인 스레드와 통신해야 합니다.

#### 문제 2
**문제**: 서비스 워커와 웹 워커의 차이점으로 올바른 것은?

**정답**: 서비스 워커는 네트워크 요청을 가로챌 수 있지만, 웹 워커는 그렇지 않다

**해설**: 서비스 워커는 네트워크 요청을 가로채고 수정할 수 있는 기능을 가지고 있어 오프라인 지원, 캐싱 전략 구현 등이 가능합니다. 반면, 웹 워커는 CPU 집약적인 작업을 메인 스레드와 별도로 처리하기 위한 목적으로 설계되었으며, 네트워크 요청을 가로채는 기능은 없습니다. 또한 서비스 워커는 페이지와 독립적인 생명주기를 가지며 여러 탭과 창에 걸쳐 작동할 수 있지만, 웹 워커는 생성한 페이지에 종속되어 있습니다.

#### 문제 3
**문제**: 웹 개발자가 서비스 워커를 사용하는 주요 이유로 올바른 것을 모두 고르세요.

**정답**: 오프라인 웹 경험 제공, 네트워크 요청 최적화, 푸시 알림 구현

**해설**: 
- 오프라인 웹 경험 제공: 서비스 워커는 리소스를 캐싱하여 인터넷 연결이 없거나 불안정한 상황에서도 웹 애플리케이션이 작동할 수 있게 합니다.
- 네트워크 요청 최적화: 서비스 워커는 네트워크 요청을 가로채고 캐시된 응답을 제공하거나 네트워크 요청을 수정하여 성능을 최적화할 수 있습니다.
- 푸시 알림 구현: 서비스 워커는 웹 푸시 API와 함께 사용하여 사용자에게 푸시 알림을 보낼 수 있습니다.
- 서버 부하 감소: 이는 서비스 워커의 직접적인 목적이라기보다는 캐싱과 네트워크 최적화의 부수적인 효과입니다.
- DOM 직접 조작: 서비스 워커는 DOM에 직접 접근할 수 없으므로 이는 올바르지 않습니다.

### 01-2 서비스 워커의 특징

#### 문제 1
**문제**: 서비스 워커가 메인 스레드와 별도로 실행되는 이유로 가장 적절한 것은?

**정답**: UI 블로킹을 방지하고 백그라운드 작업을 수행하기 위해

**해설**: 서비스 워커는 메인 스레드와 별도의 워커 스레드에서 실행됩니다. 이는 UI 블로킹을 방지하고 백그라운드 작업을 수행할 수 있게 하는 중요한 특성입니다. 메인 스레드는 DOM 조작과 사용자 인터페이스 처리를 담당하는데, 서비스 워커가 별도의 스레드에서 실행됨으로써 네트워크 요청 처리, 캐싱, 푸시 알림 등의 작업이 메인 스레드를 차단하지 않고 백그라운드에서 효율적으로 수행될 수 있습니다.

#### 문제 2
**문제**: 서비스 워커의 프록시 역할에 대한 설명으로 올바르지 않은 것은?

**정답**: 서버의 부하를 직접 모니터링할 수 있다

**해설**: 서비스 워커는 웹 애플리케이션과 네트워크 사이에서 프록시 역할을 하며, 네트워크 요청을 가로채고 수정할 수 있고, 다양한 캐싱 전략을 구현할 수 있으며, 오프라인 상태에서도 캐시된 응답을 제공할 수 있습니다. 그러나 서비스 워커는 클라이언트 측 기술로, 서버의 부하를 직접 모니터링하는 기능은 없습니다. 서버 부하 모니터링은 서버 측 도구나 별도의 모니터링 서비스를 통해 수행해야 합니다.

#### 문제 3
**문제**: 서비스 워커에서 사용되는 이벤트가 아닌 것은?

**정답**: click

**해설**: 서비스 워커는 install, activate, fetch, push, sync, message 등의 이벤트를 처리할 수 있습니다. 그러나 click 이벤트는 DOM 이벤트로, 서비스 워커에서 직접 처리할 수 없습니다. 서비스 워커는 DOM에 접근할 수 없기 때문에 click과 같은 사용자 인터페이스 이벤트는 메인 스레드에서 처리되어야 합니다. 서비스 워커가 이러한 이벤트에 반응하려면 메인 스레드에서 postMessage()를 통해 메시지를 전송해야 합니다.

#### 문제 4
**문제**: 서비스 워커의 비동기적 특성에 관한 설명으로 올바른 것은?

**정답**: 서비스 워커는 Promise 기반의 API를 주로 사용한다

**해설**: 서비스 워커는 본질적으로 비동기적인 특성을 가지고 있으며, Promise 기반의 API를 주로 사용합니다. 서비스 워커 등록(register()), 캐시 작업(caches.open(), cache.add() 등), 네트워크 요청(fetch()) 등 대부분의 서비스 워커 API는 Promise를 반환합니다. 이러한 비동기적 특성은 작업이 완료될 때까지 기다리는 동안 다른 작업을 수행할 수 있게 하여 성능을 향상시키고 효율적인 리소스 사용을 가능하게 합니다.

#### 문제 5
**문제**: 서비스 워커가 HTTPS를 요구하는 이유로 가장 적절한 것은?

**정답**: 보안상의 이유로 중간자 공격을 방지하기 위해

**해설**: 서비스 워커는 네트워크 요청을 가로채고 수정할 수 있는 강력한 기능을 가지고 있기 때문에, 보안상의 이유로 HTTPS 환경에서만 작동하도록 설계되었습니다. HTTPS는 통신 내용이 제3자에 의해 가로채지거나 변조되는 중간자 공격을 방지하고, 웹사이트의 신원을 확인할 수 있게 합니다. 이를 통해 서비스 워커의 강력한 기능이 악의적인 목적으로 사용되는 것을 방지하고, 사용자의 데이터와 프라이버시를 보호할 수 있습니다. 개발 목적으로는 localhost나 127.0.0.1과 같은 로컬 환경에서는 HTTPS 없이도 서비스 워커를 사용할 수 있습니다.

### 01-3 서비스 워커 지원 환경

#### 문제 1
**문제**: 서비스 워커 지원 여부를 확인하는 올바른 JavaScript 코드는?

**정답**: if ('serviceWorker' in navigator) { ... }

**해설**: 서비스 워커 지원 여부를 확인하는 표준적인 방법은 'serviceWorker' 속성이 navigator 객체에 존재하는지 확인하는 것입니다. 이 코드는 브라우저가 서비스 워커를 지원하는 경우에만 조건문 내부의 코드를 실행합니다. 다른 옵션들은 유효한 JavaScript 구문이 아니거나(browser.supportsServiceWorker()), 서비스 워커 지원 여부를 올바르게 확인하지 못합니다(window.serviceWorker, document.serviceWorker). 이러한 기능 감지 패턴은 점진적 향상 기법을 구현할 때 중요한 역할을 합니다.

#### 문제 2
**문제**: 서비스 워커를 지원하지 않는 브라우저에서 사용할 수 있는 대체 기술이 아닌 것은?

**정답**: WebSocket API

**해설**: WebSocket API는 클라이언트와 서버 간의 양방향 통신 채널을 제공하는 기술로, 서비스 워커의 대체 기술이라기보다는 다른 목적을 가진 별개의 웹 API입니다. IndexedDB, LocalStorage, SessionStorage는 모두 클라이언트 측 데이터 저장 메커니즘으로, 서비스 워커의 캐싱 기능을 부분적으로 대체할 수 있습니다. 특히 IndexedDB는 대용량 구조화된 데이터를 저장하는 데 사용될 수 있으며, LocalStorage와 SessionStorage는 간단한 키-값 데이터를 저장하는 데 사용될 수 있습니다.

#### 문제 3
**문제**: 서비스 워커를 사용할 때 권장되는 개발 접근 방식은?

**정답**: 점진적 향상 기법 적용하기

**해설**: 점진적 향상(Progressive Enhancement) 기법은 모든 사용자에게 기본적인 기능을 제공하고, 브라우저가 지원하는 경우에만 추가 기능을 활성화하는 접근 방식입니다. 이 방식을 사용하면 서비스 워커를 지원하지 않는 브라우저에서도 웹 애플리케이션의 핵심 기능이 작동하며, 서비스 워커를 지원하는 브라우저에서는 다음과 같은 향상된 기능을 제공할 수 있습니다:

1. **오프라인 작동**: 인터넷 연결이 없어도 이전에 방문한 페이지와 리소스를 볼 수 있습니다.
2. **성능 향상**: 이미지, 스크립트, 스타일시트 등을 캐시하여 로딩 속도를 개선합니다.
3. **네트워크 복원력**: 불안정한 네트워크 환경에서도 캐시된 콘텐츠를 제공하여 사용자 경험을 유지합니다.
4. **오프라인 대체 콘텐츠**: 네트워크 연결이 없을 때 오프라인 페이지나 대체 이미지를 제공합니다.
5. **백그라운드 동기화**: 오프라인 상태에서 사용자 작업을 저장하고, 온라인 상태가 되면 자동으로 동기화합니다.
6. **푸시 알림**: 웹 애플리케이션이 닫혀 있어도 사용자에게 알림을 보낼 수 있습니다.

예를 들어, 이미지 갤러리 웹 애플리케이션에서는 기본적으로 모든 브라우저에서 이미지를 로드하고 표시하는 기능을 제공하고, 서비스 워커를 지원하는 브라우저에서는 이미지를 캐시하여 오프라인에서도 볼 수 있게 하거나, 네트워크 오류 시 대체 이미지를 제공하는 등의 향상된 기능을 추가할 수 있습니다.

서비스 워커를 지원하는 브라우저만 타겟팅하는 것은 많은 사용자를 배제할 수 있으며, 모든 기능을 폴리필로 구현하는 것은 서비스 워커의 특성상 완전히 불가능합니다. AppCache는 현재 deprecated된 기술로, 서비스 워커와 함께 사용하는 것은 권장되지 않습니다.

## Chapter 02 서비스 워커 생명주기

### 02-1 서비스 워커 등록과 설치

#### 문제 1
**문제**: 서비스 워커 등록 시 사용하는 올바른 메서드는?

**정답**: navigator.serviceWorker.register()

**해설**: 서비스 워커를 등록하기 위해서는 `navigator.serviceWorker.register()` 메서드를 사용합니다. 이 메서드는 서비스 워커 스크립트의 URL을 매개변수로 받고, Promise를 반환합니다. 다른 옵션들은 존재하지 않는 메서드이거나(navigator.serviceWorker.create(), document.serviceWorker.install()), 잘못된 객체에서 메서드를 호출하는 경우(window.serviceWorker.register())입니다. 서비스 워커 API는 navigator 객체의 serviceWorker 속성을 통해 접근해야 합니다.

#### 문제 2
**문제**: 서비스 워커의 기본 스코프를 결정하는 요소는?

**정답**: 서비스 워커 스크립트 파일의 위치

**해설**: 서비스 워커의 기본 스코프는 서비스 워커 스크립트 파일이 위치한 디렉토리와 그 하위 디렉토리로 제한됩니다. 예를 들어, 서비스 워커 파일이 `/js/service-worker.js`에 위치한다면, 기본 스코프는 `/js/`가 되어 `/js/` 경로와 그 하위 경로의 페이지만 제어할 수 있습니다. 이는 보안상의 이유로 서비스 워커가 자신이 위치한 디렉토리보다 상위 경로의 리소스를 제어하지 못하도록 하기 위함입니다. 스코프를 명시적으로 지정하려면 `register()` 메서드의 두 번째 매개변수로 옵션 객체를 전달하여 `scope` 속성을 설정할 수 있지만, 이 경우에도 서비스 워커 파일 위치보다 상위 디렉토리로 스코프를 설정할 수는 없습니다.

#### 문제 3
**문제**: 서비스 워커 설치 과정에서 비동기 작업이 완료될 때까지 설치를 연장하기 위해 사용하는 메서드는?

**정답**: event.waitUntil()

**해설**: `event.waitUntil()` 메서드는 서비스 워커의 설치 이벤트 핸들러에서 비동기 작업이 완료될 때까지 설치 과정을 연장하는 데 사용됩니다. 이 메서드는 Promise를 인자로 받아 해당 Promise가 해결될 때까지 설치 단계를 연장합니다. 주로 캐시 초기화와 필수 리소스 캐싱과 같은 비동기 작업이 완료될 때까지 서비스 워커의 설치가 완료되지 않도록 하는 데 사용됩니다. 다른 옵션들은 존재하지 않는 메서드입니다. 설치 과정에서 `waitUntil()`을 사용하지 않으면, 비동기 작업이 완료되기 전에 설치가 완료될 수 있어 캐싱이 제대로 이루어지지 않을 수 있습니다.

#### 문제 4
**문제**: 서비스 워커가 설치된 후 대기 단계를 건너뛰고 즉시 활성화하기 위해 사용하는 메서드는?

**정답**: self.skipWaiting()

**해설**: `self.skipWaiting()` 메서드는 새로 설치된 서비스 워커가 대기 단계를 건너뛰고 즉시 활성화되도록 하는 데 사용됩니다. 일반적으로 서비스 워커는 설치된 후 기존 서비스 워커가 제어하는 페이지가 모두 닫힐 때까지 대기 상태에 머무르지만, `skipWaiting()`을 호출하면 이 대기 과정을 건너뛰고 즉시 활성화됩니다. 이는 중요한 업데이트를 즉시 적용해야 할 때 유용하지만, 페이지가 로드된 후 서비스 워커가 변경되면 예상치 못한 동작이 발생할 수 있으므로 주의해야 합니다. 다른 옵션들은 존재하지 않는 메서드이거나(self.activate(), registration.activate()), 잘못된 객체에서 메서드를 호출하는 경우(event.skipWaiting())입니다.

#### 문제 5
**문제**: 다음 중 서비스 워커 등록 과정에서 발생할 수 있는 문제가 아닌 것은?

**정답**: DOM 요소에 직접 접근 시도

**해설**: 서비스 워커 등록 과정은 웹 페이지의 JavaScript 코드에서 이루어지므로, DOM 요소에 직접 접근하는 것은 등록 과정과 관련이 없습니다. DOM 접근 문제는 서비스 워커 스크립트 내부에서 발생할 수 있는 문제로, 서비스 워커는 DOM에 직접 접근할 수 없기 때문에 DOM 조작을 시도하면 오류가 발생합니다. 반면, HTTP 환경에서 서비스 워커 등록 시도(HTTPS가 필요), 서비스 워커 스크립트 파일 경로 오류, 잘못된 스코프 설정은 모두 서비스 워커 등록 과정에서 실제로 발생할 수 있는 문제입니다. 서비스 워커는 보안상의 이유로 HTTPS 환경에서만 작동하며(localhost는 예외), 스크립트 파일 경로가 올바르지 않거나 스코프 설정이 잘못되면 등록이 실패할 수 있습니다.

### 02-2 서비스 워커 활성화와 업데이트

#### 문제 1
**문제**: 서비스 워커의 활성화 이벤트에서 주로 수행하는 작업은?

**정답**: 오래된 캐시 정리

**해설**: 서비스 워커의 `activate` 이벤트 핸들러에서는 주로 오래된 캐시를 정리하는 작업을 수행합니다. 새 버전의 서비스 워커가 활성화될 때, 이전 버전에서 사용하던 캐시를 삭제하거나 업데이트하여 스토리지 공간을 효율적으로 관리하고 오래된 리소스가 사용되지 않도록 합니다. 이 외에도 데이터베이스 마이그레이션이나 새 버전의 서비스 워커에 필요한 설정 초기화 작업을 수행할 수 있습니다. 반면, 필수 리소스 캐싱은 주로 `install` 이벤트에서 수행하고, 네트워크 요청 가로채기는 `fetch` 이벤트에서, 푸시 알림 설정은 `push` 이벤트에서 처리합니다.

#### 문제 2
**문제**: 활성화된 서비스 워커가 이미 열려있는 페이지를 즉시 제어하도록 하는 메서드는?

**정답**: clients.claim()

**해설**: `clients.claim()` 메서드는 활성화된 서비스 워커가 이미 열려있는 페이지를 즉시 제어할 수 있게 해줍니다. 기본적으로 서비스 워커는 활성화된 후에도 이미 로드된 페이지는 제어하지 않고 새로 열리는 페이지만 제어하게 됩니다. `clients.claim()`을 호출하면 활성화된 서비스 워커가 즉시 모든 열린 페이지를 제어할 수 있게 되어, 중요한 업데이트를 즉시 적용하거나 개발 중에 서비스 워커 변경사항을 빠르게 테스트할 수 있습니다. 다른 옵션들은 존재하지 않는 메서드이거나(self.activate(), self.control()), 잘못된 객체에서 메서드를 호출하는 경우(navigator.serviceWorker.claim())입니다.

#### 문제 3
**문제**: 서비스 워커 스크립트가 업데이트되었다고 브라우저가 인식하는 조건은?

**정답**: 서비스 워커 파일의 내용이 1바이트라도 변경된 경우

**해설**: 브라우저는 서비스 워커 스크립트를 바이트 단위로 비교하여 변경 사항이 있는지 확인합니다. 스크립트 파일의 내용이 1바이트라도 변경되었다면, 브라우저는 이를 새 버전으로 간주하고 업데이트 과정을 시작합니다. 파일의 수정 날짜나 이름 변경은 브라우저가 업데이트를 감지하는 기준이 아니며, 파일 크기의 변화 비율도 관련이 없습니다. 이러한 바이트 단위 비교 방식 때문에, 서비스 워커 코드에 주석 하나만 추가하거나 공백 하나만 변경해도 브라우저는 이를 새 버전으로 인식합니다. 이 특성을 활용하여 서비스 워커를 강제로 업데이트할 수도 있습니다.

#### 문제 4
**문제**: 서비스 워커 업데이트를 수동으로 트리거하는 올바른 메서드는?

**정답**: registration.update()

**해설**: 서비스 워커 업데이트를 수동으로 트리거하려면 `ServiceWorkerRegistration` 객체의 `update()` 메서드를 사용합니다. 이 메서드는 서비스 워커 스크립트를 다시 다운로드하고 변경 사항이 있는지 확인합니다. 일반적으로 `navigator.serviceWorker.ready.then(registration => registration.update())` 형태로 사용됩니다. 이 방법은 중요한 업데이트를 즉시 적용해야 할 때나 사용자에게 업데이트 알림을 표시하고 싶을 때 유용합니다. 다른 옵션들은 존재하지 않는 메서드입니다(navigator.serviceWorker.update(), self.update(), serviceWorker.checkForUpdates()).

#### 문제 5
**문제**: 다음 중 서비스 워커 버전 관리 전략으로 적절하지 않은 것은? (복수 응답)

**정답**: 서비스 워커 파일 이름에 버전 번호 포함, localStorage에 버전 정보 저장

**해설**: 
- 서비스 워커 파일 이름에 버전 번호를 포함하는 방법(예: service-worker-v2.js)은 등록 코드도 함께 업데이트해야 하므로 효율적인 버전 관리 전략이 아닙니다. 이는 서비스 워커 등록 코드가 변경될 때마다 사용자가 페이지를 새로고침해야 하므로 원활한 업데이트가 어렵습니다.
- localStorage에 버전 정보를 저장하는 방법은 서비스 워커의 버전 관리에 적합하지 않습니다. localStorage는 웹 페이지의 JavaScript에서 접근할 수 있지만, 서비스 워커는 독립적인 실행 컨텍스트를 가지므로 localStorage에 저장된 정보를 직접 활용하기 어렵습니다.
- 반면, 캐시 이름에 버전 번호를 포함하는 방법(예: app-cache-v1.2.3)은 서비스 워커 내에서 캐시를 효과적으로 관리할 수 있게 해줍니다.
- importScripts()를 사용하여 버전 정보가 포함된 별도의 파일을 임포트하는 방법은 서비스 워커 파일을 변경하지 않고도 버전을 업데이트할 수 있어 효율적입니다.
- 서비스 워커 코드에 버전 상수를 정의하는 방법(예: const VERSION = 'v1.2.3')도 간단하고 직관적인 버전 관리 방법입니다.

### 02-3 서비스 워커 상태 관리

#### 문제 1
**문제**: 서비스 워커의 상태를 확인하기 위해 사용하는 객체는?

**정답**: ServiceWorkerRegistration

**해설**: `ServiceWorkerRegistration` 객체는 서비스 워커 등록에 관한 정보를 제공하며, 서비스 워커의 상태를 확인하고 관리하는 데 사용됩니다. 이 객체는 `installing`, `waiting`, `active` 등의 속성을 통해 서비스 워커의 현재 상태를 확인할 수 있으며, `update()`, `unregister()` 등의 메서드를 제공하여 서비스 워커를 관리할 수 있게 합니다. `ServiceWorkerController`와 `ServiceWorkerState`, `ServiceWorkerManager`는 존재하지 않는 객체입니다.

#### 문제 2
**문제**: 서비스 워커의 상태 중 '설치는 완료되었지만 아직 활성화되지 않은 상태'를 나타내는 것은?

**정답**: installed

**해설**: 서비스 워커의 상태 중 `installed`(또는 `waiting`이라고도 함)는 서비스 워커의 설치가 완료되었지만 아직 활성화되지 않은 상태를 나타냅니다. 이 상태에서 서비스 워커는 이전 서비스 워커가 더 이상 사용되지 않을 때까지 대기하거나, `skipWaiting()` 메서드가 호출될 때까지 대기합니다. `installing`은 설치 중인 상태, `activating`은 활성화 중인 상태, `activated`는 활성화가 완료된 상태를 나타냅니다.

#### 문제 3
**문제**: 서비스 워커 등록을 해제하는 메서드는?

**정답**: registration.unregister()

**해설**: 서비스 워커 등록을 해제하려면 `ServiceWorkerRegistration` 객체의 `unregister()` 메서드를 사용합니다. 이 메서드는 서비스 워커 등록을 해제하고 Promise를 반환합니다. 일반적으로 `navigator.serviceWorker.getRegistration().then(registration => registration.unregister())` 형태로 사용됩니다. `registration.remove()`, `registration.delete()`, `registration.deactivate()`는 존재하지 않는 메서드입니다.

#### 문제 4
**문제**: 서비스 워커의 상태 변경을 감지하는 이벤트는?

**정답**: statechange

**해설**: 서비스 워커의 상태 변경은 `statechange` 이벤트를 통해 감지할 수 있습니다. 이 이벤트는 서비스 워커의 상태가 변경될 때마다 발생하며, 이벤트 핸들러에서 `event.target.state`를 통해 새로운 상태를 확인할 수 있습니다. 주로 `serviceWorker.addEventListener('statechange', event => { ... })` 형태로 사용됩니다. `statuschange`, `change`, `update`는 서비스 워커의 상태 변경과 관련된 이벤트가 아닙니다.

#### 문제 5
**문제**: 다음 중 서비스 워커 상태 관리와 관련된 올바른 설명은? (복수 응답)

**정답**: 새로운 서비스 워커가 설치되면 `updatefound` 이벤트가 발생한다, 활성화된 서비스 워커가 변경되면 `controllerchange` 이벤트가 발생한다, `getRegistrations()` 메서드를 사용하여 모든 서비스 워커 등록을 가져올 수 있다

**해설**: 
- 새로운 서비스 워커가 설치되면 `updatefound` 이벤트가 발생합니다. 이 이벤트는 `ServiceWorkerRegistration` 객체에서 발생하며, 새로운 서비스 워커가 발견되고 설치 과정이 시작될 때 트리거됩니다.
- 활성화된 서비스 워커가 변경되면 `controllerchange` 이벤트가 발생합니다. 이 이벤트는 `navigator.serviceWorker` 객체에서 발생하며, 페이지를 제어하는 서비스 워커가 변경될 때 트리거됩니다.
- `getRegistrations()` 메서드를 사용하여 모든 서비스 워커 등록을 가져올 수 있습니다. 이 메서드는 `navigator.serviceWorker` 객체에서 제공되며, 현재 페이지의 출처에 등록된 모든 서비스 워커 등록을 Promise로 반환합니다.
- 서비스 워커의 상태는 `navigator.serviceWorker.state`로 직접 확인할 수 없습니다. 서비스 워커의 상태는 `ServiceWorker` 객체의 `state` 속성을 통해 확인해야 합니다.
- 서비스 워커 등록을 해제하면 관련 캐시는 자동으로 삭제되지 않습니다. 캐시를 정리하려면 별도로 `caches.delete()` 메서드를 호출해야 합니다.

## Chapter 03 서비스 워커와 캐싱

### 03-1 Cache API 기초

#### 문제 1
**문제**: Cache API의 주요 목적은 무엇인가요?

**정답**: HTTP 요청과 응답 쌍의 저장 및 관리

**해설**: Cache API의 주요 목적은 HTTP 요청과 응답 쌍을 저장하고 관리하는 것입니다. 이를 통해 웹 애플리케이션은 네트워크 연결 없이도 이전에 캐시된 리소스에 접근할 수 있어 오프라인 기능과 성능 향상을 제공할 수 있습니다. Cache API는 서비스 워커와 함께 사용되어 네트워크 요청을 가로채고 캐시된 응답을 제공하는 데 중요한 역할을 합니다. 브라우저 히스토리 관리, 사용자 인증 정보 저장, 웹 페이지 성능 측정은 Cache API의 주요 목적이 아닙니다.

#### 문제 2
**문제**: 캐시에 응답을 저장하기 위해 사용하는 메서드가 아닌 것은?

**정답**: cache.store()

**해설**: Cache API에서 응답을 저장하기 위해 사용하는 메서드는 `cache.put()`, `cache.add()`, `cache.addAll()`입니다. `cache.store()`는 존재하지 않는 메서드입니다. `cache.put()`은 요청-응답 쌍을 직접 저장하고, `cache.add()`는 URL을 가져와서 응답을 캐시에 저장하며, `cache.addAll()`은 URL 배열을 가져와서 모든 응답을 캐시에 저장합니다. 이러한 메서드들은 모두 Promise를 반환하여 비동기 작업을 처리합니다.

#### 문제 3
**문제**: 캐시에서 응답을 검색하는 메서드는?

**정답**: cache.match()

**해설**: 캐시에서 응답을 검색하기 위해 사용하는 메서드는 `cache.match()`입니다. 이 메서드는 요청 객체나 URL 문자열을 인자로 받아 해당 요청에 대한 캐시된 응답을 찾습니다. 일치하는 응답이 없으면 `undefined`를 반환합니다. 또한 `caches.match()`를 사용하여 모든 캐시에서 응답을 검색할 수도 있습니다. `cache.get()`, `cache.find()`, `cache.retrieve()`는 Cache API에 존재하지 않는 메서드입니다.

#### 문제 4
**문제**: 서비스 워커의 어떤 이벤트에서 주로 오래된 캐시를 정리하나요?

**정답**: activate

**해설**: 서비스 워커의 `activate` 이벤트에서 주로 오래된 캐시를 정리합니다. 서비스 워커가 업데이트되어 새 버전이 활성화될 때, 이전 버전에서 사용하던 캐시를 삭제하거나 업데이트하는 작업을 `activate` 이벤트 핸들러에서 수행합니다. 이는 스토리지 공간을 효율적으로 관리하고 오래된 리소스가 사용되지 않도록 하기 위함입니다. `install` 이벤트는 주로 필수 리소스를 캐싱하는 데 사용되고, `fetch` 이벤트는 네트워크 요청을 가로채는 데 사용되며, `message` 이벤트는 웹 페이지와 서비스 워커 간의 통신에 사용됩니다.

#### 문제 5
**문제**: Cache API와 HTTP 캐시의 차이점으로 올바른 것은? (복수 응답)

**정답**: Cache API는 프로그래밍 방식으로 완전히 제어할 수 있다, HTTP 캐시는 HTTP 헤더에 의해 제어된다, Cache API는 오프라인 사용을 위해 설계되었다

**해설**: 
- Cache API는 프로그래밍 방식으로 완전히 제어할 수 있습니다. 개발자는 JavaScript를 통해 캐시의 생성, 읽기, 업데이트, 삭제를 직접 제어할 수 있습니다.
- HTTP 캐시는 HTTP 헤더에 의해 제어됩니다. Cache-Control, Expires, ETag 등의 HTTP 헤더를 통해 브라우저의 캐싱 동작을 지시합니다.
- Cache API는 오프라인 사용을 위해 설계되었습니다. 서비스 워커와 함께 사용하여 네트워크 연결 없이도 웹 애플리케이션이 작동할 수 있게 합니다.
- HTTP 캐시는 JavaScript로 직접 접근할 수 없습니다. 브라우저에 의해 자동으로 관리되며, 개발자가 직접 조작할 수 없습니다.
- Cache API는 서비스 워커 없이도 사용할 수 있지만, 주로 서비스 워커와 함께 사용하여 오프라인 기능을 구현합니다. 서비스 워커 없이 사용할 경우 제한된 기능만 사용할 수 있습니다.

### 03-2 캐싱 전략

#### 문제 1
**문제**: 정적 자산(CSS, JavaScript, 이미지)에 가장 적합한 캐싱 전략은 무엇인가요?

**정답**: 캐시 우선

**해설**: 정적 자산(CSS, JavaScript, 이미지)에는 캐시 우선(Cache First) 전략이 가장 적합합니다. 이러한 리소스는 자주 변경되지 않으며, 빠른 로딩 시간과 대역폭 절약이 중요하기 때문입니다. 캐시 우선 전략은 먼저 캐시에서 응답을 찾고, 캐시에 없는 경우에만 네트워크에서 리소스를 가져옵니다. 이를 통해 네트워크 요청을 최소화하고 빠른 응답 시간을 제공하며, 오프라인 상태에서도 이러한 리소스를 사용할 수 있게 합니다. 정적 자산은 일반적으로 빌드 과정에서 파일명이 변경되거나 버전이 포함되므로, 업데이트가 필요할 때 새로운 URL로 요청되어 자연스럽게 캐시가 갱신됩니다.

#### 문제 2
**문제**: 다음 중 스테일-와일-리밸리데이트 전략의 특징이 아닌 것은?

**정답**: 네트워크 요청이 실패하면 오류를 반환한다

**해설**: 스테일-와일-리밸리데이트(Stale-While-Revalidate) 전략에서는 네트워크 요청이 실패해도 오류를 반환하지 않습니다. 이 전략은 캐시된 응답을 즉시 반환하면서 동시에 백그라운드에서 네트워크 요청을 보내 캐시를 업데이트합니다. 네트워크 요청이 실패하더라도 이미 캐시된 응답을 사용자에게 제공했기 때문에 사용자 경험에 영향을 주지 않습니다. 스테일-와일-리밸리데이트 전략의 주요 특징은 캐시된 응답을 즉시 반환하여 빠른 응답 시간을 제공하고, 백그라운드에서 캐시를 지속적으로 업데이트하여 다음 요청 시 최신 콘텐츠를 제공하는 것입니다.

#### 문제 3
**문제**: 실시간 채팅 메시지나 금융 거래 데이터와 같은 항상 최신 상태여야 하는 데이터에 가장 적합한 전략은?

**정답**: 네트워크 전용

**해설**: 실시간 채팅 메시지나 금융 거래 데이터와 같이 항상 최신 상태여야 하는 데이터에는 네트워크 전용(Network Only) 전략이 가장 적합합니다. 이러한 데이터는 최신성이 매우 중요하며, 오래된 데이터를 표시하는 것이 사용자에게 혼란을 줄 수 있기 때문입니다. 네트워크 전용 전략은 항상 네트워크에서만 리소스를 가져오고 캐시를 사용하지 않습니다. 이를 통해 항상 최신 데이터를 제공하고 민감한 정보가 캐시되지 않도록 합니다. 단점으로는 오프라인 상태에서 작동하지 않고 네트워크 요청이 항상 발생하므로 대역폭 사용량이 높다는 점이 있지만, 실시간 데이터의 정확성이 더 중요한 경우에는 이러한 단점을 감수할 가치가 있습니다.

#### 문제 4
**문제**: 캐시 폴백 전략의 주요 목적은 무엇인가요?

**정답**: 오프라인 사용자 경험 향상

**해설**: 캐시 폴백(Cache Fallback) 전략의 주요 목적은 오프라인 사용자 경험을 향상시키는 것입니다. 이 전략은 먼저 네트워크에서 리소스를 가져오려고 시도하고, 네트워크 요청이 실패할 경우 캐시로 폴백하며, 캐시에도 없는 경우 기본 오프라인 페이지나 이미지와 같은 대체 콘텐츠를 제공합니다. 이를 통해 네트워크 연결이 불안정하거나 없는 상황에서도 사용자에게 최소한의 기능과 콘텐츠를 제공할 수 있습니다. 캐시 폴백 전략은 리소스 유형별로 다른 폴백을 제공할 수 있어 사용자 경험을 더욱 개선할 수 있습니다. 예를 들어, HTML 요청에는 오프라인 페이지를, 이미지 요청에는 기본 이미지를 제공하는 등의 방식으로 구현할 수 있습니다.

#### 문제 5
**문제**: 다음 중 캐싱 전략 선택 시 고려해야 할 요소가 아닌 것은? (복수 응답)

**정답**: 리소스의 파일 크기, 브라우저의 종류

**해설**: 
- 리소스의 파일 크기는 캐싱 전략 선택 시 주요 고려 요소가 아닙니다. 파일 크기보다는 리소스의 특성(변경 빈도, 중요도 등)이 전략 선택에 더 중요한 영향을 미칩니다.
- 브라우저의 종류도 캐싱 전략 선택 시 주요 고려 요소가 아닙니다. 현대 브라우저들은 대부분 Cache API와 서비스 워커를 지원하므로, 특정 브라우저에 맞춰 전략을 변경할 필요는 없습니다.
- 리소스가 얼마나 자주 변경되는지는 중요한 고려 요소입니다. 자주 변경되는 리소스는 네트워크 우선이나 스테일-와일-리밸리데이트 전략이 적합하고, 거의 변경되지 않는 리소스는 캐시 우선이나 캐시 전용 전략이 적합합니다.
- 오프라인 작동의 중요성도 중요한 고려 요소입니다. 오프라인 작동이 중요한 경우 캐시 우선이나 캐시 전용 전략이 적합하고, 덜 중요한 경우 네트워크 우선이나 네트워크 전용 전략이 적합합니다.
- 데이터의 민감도도 중요한 고려 요소입니다. 민감한 데이터는 캐시되지 않도록 네트워크 전용 전략을 사용하는 것이 좋습니다.

#### 문제 6
**문제**: 앱 셸(App Shell) 아키텍처의 핵심 UI 컴포넌트에 가장 적합한 캐싱 전략은?

**정답**: 캐시 전용

**해설**: 앱 셸(App Shell) 아키텍처의 핵심 UI 컴포넌트에는 캐시 전용(Cache Only) 전략이 가장 적합합니다. 앱 셸은 애플리케이션의 기본 UI 구조로, HTML, CSS, JavaScript 등 애플리케이션의 핵심 인프라를 구성하는 최소한의 정적 리소스 집합입니다. 이러한 컴포넌트는 거의 변경되지 않으며, 애플리케이션이 빠르게 로드되고 즉시 사용 가능한 상태가 되도록 하는 데 중요합니다. 캐시 전용 전략은 오직 캐시에서만 리소스를 제공하고 네트워크 요청을 전혀 하지 않기 때문에, 매우 빠른 응답 시간을 제공하고 완전한 오프라인 작동을 보장합니다. 앱 셸 컴포넌트는 서비스 워커 설치 단계에서 미리 캐시되어야 하며, 업데이트가 필요한 경우 새 버전의 서비스 워커를 통해 관리됩니다.

#### 문제 7
**문제**: 블로그 포스트나 뉴스 기사와 같이 빠른 응답이 중요하지만 최신 상태도 유지해야 하는 콘텐츠에 가장 적합한 전략은?

**정답**: 스테일-와일-리밸리데이트

**해설**: 블로그 포스트나 뉴스 기사와 같이 빠른 응답이 중요하지만 최신 상태도 유지해야 하는 콘텐츠에는 스테일-와일-리밸리데이트(Stale-While-Revalidate) 전략이 가장 적합합니다. 이 전략은 캐시된 응답을 즉시 반환하면서 동시에 백그라운드에서 네트워크 요청을 보내 캐시를 업데이트합니다. 이를 통해 사용자는 빠르게 콘텐츠를 볼 수 있으면서도, 다음 방문 시에는 업데이트된 콘텐츠를 볼 수 있게 됩니다. 블로그 포스트나 뉴스 기사는 즉시 로드되어야 하지만, 약간의 지연 후에 최신 콘텐츠로 업데이트되는 것이 허용되는 경우가 많습니다. 스테일-와일-리밸리데이트 전략은 이러한 요구사항에 완벽하게 부합하며, 사용자 경험과 콘텐츠 최신성 사이의 균형을 효과적으로 맞출 수 있습니다.

### 03-3 동적 콘텐츠 캐싱

#### 문제 1
**문제**: API 응답을 캐싱할 때 가장 중요한 고려사항은 무엇인가요?

**정답**: 데이터 신선도

**해설**: API 응답을 캐싱할 때 가장 중요한 고려사항은 데이터 신선도입니다. 동적 콘텐츠는 정적 자산과 달리 자주 변경될 수 있으며, 오래된 데이터를 제공하면 사용자 경험이 저하되거나 잘못된 정보를 제공할 수 있습니다. 따라서 API 응답을 캐싱할 때는 타임스탬프 기반 캐싱, 만료 시간 설정, 조건부 요청 등을 통해 데이터의 신선도를 관리해야 합니다. 응답 크기는 캐싱 전략 선택에 영향을 미치는 요소가 아니며, 브라우저 호환성은 대부분의 현대 브라우저가 Cache API를 지원하므로 주요 고려사항이 아닙니다. 네트워크 속도는 캐싱의 이점을 강화할 수 있지만, 캐싱 전략 자체를 결정하는 주요 요소는 아닙니다.

#### 문제 2
**문제**: 다음 중 조건부 캐싱에 사용될 수 있는 조건이 아닌 것은?

**정답**: 브라우저 창 크기

**해설**: 브라우저 창 크기는 조건부 캐싱에 사용되는 조건이 아닙니다. 브라우저 창 크기는 사용자 인터페이스 레이아웃과 관련된 클라이언트 측 정보로, 서버 응답이나 캐싱 전략을 결정하는 데 일반적으로 사용되지 않습니다. 반면, 사용자 인증 상태(인증된 사용자와 인증되지 않은 사용자에 대해 다른 캐싱 전략 적용), HTTP 요청 메서드(GET 요청은 캐싱하고 POST, PUT, DELETE 요청은 캐싱하지 않음), 데이터 유형(제품 정보는 캐시 우선, 가격 정보는 네트워크 우선 등)은 모두 조건부 캐싱 결정에 일반적으로 사용되는 유효한 조건입니다.

#### 문제 3
**문제**: 캐시된 API 응답의 신선도를 관리하는 방법으로 적절한 것은? (복수 응답)

**정답**: 타임스탬프를 응답에 추가하여 만료 시간 설정, Cache-Control 헤더의 max-age 값 활용, ETag와 If-None-Match 헤더를 활용한 조건부 요청, 주기적으로 백그라운드 동기화를 통해 캐시 갱신

**해설**: 
- 타임스탬프를 응답에 추가하여 만료 시간을 설정하는 방법은 캐시된 응답이 얼마나 오래되었는지 추적하고 특정 시간이 지나면 새로운 데이터를 요청하도록 하는 효과적인 방법입니다.
- Cache-Control 헤더의 max-age 값을 활용하는 것은 서버에서 제공하는 캐싱 지시사항을 존중하여 지정된 시간 동안만 응답을 캐시하는 표준적인 방법입니다.
- ETag와 If-None-Match 헤더를 활용한 조건부 요청은 리소스가 변경되었는지 효율적으로 확인하여 필요한 경우에만 새 데이터를 다운로드하는 방법입니다.
- 주기적으로 백그라운드 동기화를 통해 캐시를 갱신하는 것은 사용자 상호작용 없이도 정기적으로 캐시된 데이터를 최신 상태로 유지할 수 있는 방법입니다.
- 모든 API 응답을 영구적으로 캐싱하는 것은 적절한 방법이 아닙니다. 이는 오래된 데이터를 계속 제공하게 되어 사용자에게 잘못된 정보를 제공할 수 있습니다.

#### 문제 4
**문제**: 다음 중 ETag 헤더의 주요 목적은 무엇인가요?

**정답**: 리소스 변경 여부 확인

**해설**: ETag(Entity Tag) 헤더의 주요 목적은 리소스의 변경 여부를 확인하는 것입니다. 서버는 각 리소스에 대해 고유한 식별자(ETag)를 생성하여 응답 헤더에 포함시킵니다. 클라이언트는 이후 요청 시 If-None-Match 헤더에 이전에 받은 ETag 값을 포함시켜 조건부 요청을 보냅니다. 서버는 현재 리소스의 ETag와 요청의 If-None-Match 값을 비교하여 리소스가 변경되지 않았다면 304 Not Modified 응답을 반환하고, 변경되었다면 새로운 리소스와 함께 200 OK 응답을 반환합니다. 이를 통해 불필요한 데이터 전송을 줄이고 대역폭을 절약할 수 있습니다. ETag는 응답 압축 방식을 지정하거나, 인증 토큰을 제공하거나, 캐시 저장 위치를 지정하는 데 사용되지 않습니다.

#### 문제 5
**문제**: IndexedDB와 Cache API를 함께 사용하는 주된 이유는 무엇인가요?

**정답**: 구조화된 데이터 쿼리와 원본 응답 모두 관리

**해설**: IndexedDB와 Cache API를 함께 사용하는 주된 이유는 구조화된 데이터 쿼리와 원본 응답을 모두 효과적으로 관리하기 위함입니다. Cache API는 HTTP 요청과 응답 쌍을 그대로 저장하는 데 최적화되어 있어 원본 응답을 캐싱하고 빠르게 제공하는 데 적합합니다. 반면 IndexedDB는 구조화된 데이터를 저장하고 인덱싱, 검색, 필터링 등 복잡한 쿼리 작업을 수행하는 데 적합합니다. 두 API를 함께 사용하면 Cache API로 원본 HTTP 응답을 캐싱하고, IndexedDB로 응답 데이터를 구조화하여 저장함으로써 각 API의 장점을 활용할 수 있습니다. 이는 브라우저 호환성 향상이나 더 많은 저장 공간 확보, 서비스 워커 설치 속도 향상과는 직접적인 관련이 없습니다.

## Chapter 04 서비스 워커 이벤트 처리

### 04-1 Fetch 이벤트

#### 문제 1
**문제**: Fetch 이벤트에서 사용자 정의 응답을 제공하기 위해 사용하는 메서드는 무엇인가요?

**정답**: event.respondWith()

**해설**: Fetch 이벤트에서 사용자 정의 응답을 제공하기 위해서는 `event.respondWith()` 메서드를 사용합니다. 이 메서드는 Response 객체나 Response 객체로 해결되는 Promise를 인자로 받아, 네트워크 요청에 대한 응답을 제어할 수 있게 합니다. `event.respondWith()`를 호출하지 않으면 브라우저는 기본 네트워크 요청을 수행합니다. `event.preventDefault()`는 일반적인 DOM 이벤트를 취소하는 메서드이며, `event.waitUntil()`은 서비스 워커의 생명주기 이벤트에서 비동기 작업이 완료될 때까지 이벤트를 연장하는 메서드입니다. `event.respond()`는 존재하지 않는 메서드입니다.

#### 문제 2
**문제**: 다음 중 Request 객체의 속성이 아닌 것은?

**정답**: statusCode

**해설**: `statusCode`는 Request 객체의 속성이 아니라 Response 객체의 속성입니다(정확히는 `status`). Request 객체는 네트워크 요청에 대한 정보를 담고 있으며, `url`(요청 URL), `method`(HTTP 메서드), `headers`(HTTP 헤더), `body`(요청 본문) 등의 속성을 포함합니다. 또한 `mode`, `credentials`, `cache`, `redirect`, `referrer`, `destination` 등의 속성도 가지고 있습니다. 상태 코드는 서버의 응답에 포함되는 정보이므로 Request 객체가 아닌 Response 객체의 속성입니다.

#### 문제 3
**문제**: 서비스 워커에서 네트워크 요청을 가로채서 다른 URL로 리다이렉트하는 것을 무엇이라고 하나요?

**정답**: 요청 변환

**해설**: 서비스 워커에서 네트워크 요청을 가로채서 다른 URL로 리다이렉트하는 것을 '요청 변환'이라고 합니다. 이는 원래 요청을 수정하여 다른 리소스를 요청하거나, 요청 헤더를 변경하는 등의 작업을 포함합니다. 예를 들어, 특정 도메인의 요청을 다른 도메인으로 리다이렉트하거나, 파일 버전을 변경하는 등의 작업을 수행할 수 있습니다. 이는 서비스 워커의 강력한 기능 중 하나로, 네트워크 요청을 프로그래밍 방식으로 제어할 수 있게 해줍니다. 'URL 리매핑'은 비슷한 개념이지만 공식 용어는 아니며, '응답 변환'은 네트워크 응답을 수정하는 것을 의미하고, '프록시 리다이렉션'은 일반적인 용어로 정확한 기술 용어가 아닙니다.

#### 문제 4
**문제**: 다음 중 Fetch 이벤트 핸들러에서 오프라인 상태를 처리하는 올바른 방법은?

**정답**: fetch() 호출 시 catch() 블록을 사용한다

**해설**: Fetch 이벤트 핸들러에서 오프라인 상태를 처리하는 올바른 방법은 `fetch()` 호출 시 `catch()` 블록을 사용하는 것입니다. 네트워크 연결이 없는 경우 `fetch()` 요청은 실패하고 Promise는 거부(reject)됩니다. 이때 `catch()` 블록에서 오류를 처리하고 캐시된 응답이나 기본 오프라인 콘텐츠를 제공할 수 있습니다. `fetch()` 함수를 사용하지 않는 방법은 네트워크 요청 자체를 하지 않는 것이므로 오프라인 상태를 처리하는 방법이 아닙니다. `navigator.onLine` 속성은 현재 온라인 상태를 확인할 수 있지만, 네트워크 요청 실패를 직접 처리하지는 않습니다. `window.addEventListener('offline')`은 오프라인 상태로 전환될 때 이벤트를 감지하는 방법이지만, 이미 진행 중인 네트워크 요청의 실패를 처리하지는 않습니다.

#### 문제 5
**문제**: 다음 중 서비스 워커의 Fetch 이벤트를 활용한 성능 최적화 기법이 아닌 것은? (복수 응답)

**정답**: 응답 압축, DOM 조작

**해설**: 
- 응답 압축은 서비스 워커의 Fetch 이벤트를 활용한 성능 최적화 기법이 아닙니다. 응답 압축은 주로 서버 측에서 수행되며, 서비스 워커는 이미 압축된 응답을 처리할 뿐입니다.
- DOM 조작도 서비스 워커의 Fetch 이벤트를 활용한 성능 최적화 기법이 아닙니다. 서비스 워커는 DOM에 직접 접근할 수 없으며, Fetch 이벤트는 네트워크 요청을 처리하는 데 사용됩니다.
- 프리로딩은 사용자가 방문할 가능성이 높은 페이지나 리소스를 미리 캐시에 저장하여 빠른 응답을 제공하는 유효한 최적화 기법입니다.
- 조건부 요청은 If-Modified-Since 또는 If-None-Match 헤더를 사용하여 불필요한 데이터 전송을 줄이는 유효한 최적화 기법입니다.
- 스트리밍 응답 처리는 대용량 데이터를 처리하거나 점진적으로 콘텐츠를 로드하는 유효한 최적화 기법입니다.

#### 문제 6
**문제**: 서비스 워커에서 HTML 응답을 가로채서 내용을 수정하는 기법을 무엇이라고 하나요?

**정답**: 응답 변환

**해설**: 서비스 워커에서 HTML 응답을 가로채서 내용을 수정하는 기법을 '응답 변환'이라고 합니다. 이 기법은 네트워크에서 받은 응답을 가로채서 내용을 수정한 후 새로운 Response 객체를 생성하여 반환하는 방식으로 구현됩니다. 예를 들어, HTML 페이지에 오프라인 배너를 추가하거나, 특정 스크립트를 삽입하거나, 콘텐츠를 필터링하는 등의 작업을 수행할 수 있습니다. 'HTML 인터셉션'과 '콘텐츠 스크립팅'은 비슷한 개념을 설명할 수 있지만 공식 용어는 아니며, 'DOM 조작'은 서비스 워커에서 직접 수행할 수 없는 작업입니다(서비스 워커는 DOM에 접근할 수 없음).

#### 문제 7
**문제**: Fetch 이벤트에서 백그라운드 작업을 계속하기 위해 사용하는 메서드는 무엇인가요?

**정답**: event.waitUntil()

**해설**: Fetch 이벤트에서 백그라운드 작업을 계속하기 위해 `event.waitUntil()` 메서드를 사용합니다. 이 메서드는 서비스 워커가 응답을 반환한 후에도 백그라운드 작업을 계속할 수 있게 해줍니다. 예를 들어, 응답을 즉시 반환하면서 동시에 캐시를 업데이트하거나, 분석 데이터를 전송하거나, 다른 리소스를 프리로딩하는 등의 작업을 수행할 수 있습니다. `event.continue()`, `event.background()`, `event.async()`는 존재하지 않는 메서드입니다.

### 04-2 Push 이벤트와 알림

#### 문제 1
**문제**: Push API를 사용하기 위해 필요한 권한은 무엇인가요?

**정답**: notifications

**해설**: Push API를 사용하기 위해서는 'notifications' 권한이 필요합니다. 이 권한은 웹 애플리케이션이 사용자에게 시스템 알림을 표시할 수 있도록 허용합니다. 푸시 알림을 구현하기 위해서는 사용자로부터 이 권한을 명시적으로 요청해야 하며, 이는 일반적으로 `Notification.requestPermission()` 메서드를 통해 이루어집니다. 사용자가 권한을 허용하면 웹 애플리케이션은 서비스 워커를 통해 푸시 메시지를 수신하고 알림을 표시할 수 있게 됩니다. 위치 정보(geolocation), 마이크(microphone), 카메라(camera) 권한은 푸시 알림과 직접적인 관련이 없습니다.

#### 문제 2
**문제**: 푸시 메시지 구독을 생성하는 데 사용되는 인터페이스는 무엇인가요?

**정답**: PushManager

**해설**: 푸시 메시지 구독을 생성하는 데 사용되는 인터페이스는 `PushManager`입니다. 이 인터페이스는 서비스 워커 등록 객체의 `pushManager` 속성을 통해 접근할 수 있으며, 푸시 메시지 구독을 생성하고 관리하는 메서드를 제공합니다. 주요 메서드로는 `subscribe()`(새 구독 생성), `getSubscription()`(기존 구독 정보 가져오기), `permissionState()`(현재 푸시 알림 권한 상태 확인) 등이 있습니다. `NotificationManager`, `SubscriptionManager`, `MessageManager`는 웹 표준 Push API에 존재하지 않는 인터페이스입니다.

#### 문제 3
**문제**: 서비스 워커에서 푸시 메시지를 수신할 때 발생하는 이벤트는 무엇인가요?

**정답**: push

**해설**: 서비스 워커에서 푸시 메시지를 수신할 때 발생하는 이벤트는 `push` 이벤트입니다. 이 이벤트는 푸시 서비스로부터 메시지가 도착했을 때 서비스 워커에서 발생하며, 이벤트 핸들러에서 메시지 데이터를 처리하고 사용자에게 알림을 표시하는 등의 작업을 수행할 수 있습니다. 일반적으로 `self.addEventListener('push', event => { ... })` 형태로 이벤트 핸들러를 등록합니다. `message` 이벤트는 웹 페이지와 서비스 워커 간의 통신에 사용되고, `notification` 이벤트는 존재하지 않으며, `sync` 이벤트는 백그라운드 동기화에 사용됩니다.

#### 문제 4
**문제**: VAPID 키의 주요 목적은 무엇인가요?

**정답**: 서버와 푸시 서비스 간의 인증

**해설**: VAPID(Voluntary Application Server Identification) 키의 주요 목적은 서버와 푸시 서비스 간의 인증입니다. VAPID는 애플리케이션 서버가 푸시 서비스에 자신을 식별하고 인증할 수 있게 해주는 표준으로, 공개 키와 비밀 키 쌍을 사용합니다. 이를 통해 푸시 서비스는 메시지가 합법적인 서버에서 온 것인지 확인할 수 있으며, 악의적인 서버가 사용자에게 스팸 메시지를 보내는 것을 방지할 수 있습니다. 또한 VAPID를 사용하면 푸시 서비스가 문제가 발생했을 때 연락할 수 있는 연락처 정보를 제공할 수 있습니다. VAPID 키는 푸시 메시지 암호화, 사용자 식별, 알림 그룹화와는 직접적인 관련이 없습니다.

#### 문제 5
**문제**: 다음 중 Notifications API의 옵션이 아닌 것은? (복수 응답)

**정답**: priority, frequency

**해설**: 
- `priority`는 Notifications API의 옵션이 아닙니다. 알림의 우선순위를 지정하는 옵션은 Android 알림에서 사용되지만, 웹 Notifications API에는 포함되어 있지 않습니다.
- `frequency`도 Notifications API의 옵션이 아닙니다. 알림 빈도를 제어하는 표준 옵션은 없으며, 이는 애플리케이션 로직에서 관리해야 합니다.
- `body`는 유효한 옵션으로, 알림의 본문 텍스트를 지정합니다.
- `icon`은 유효한 옵션으로, 알림에 표시될 아이콘 이미지의 URL을 지정합니다.
- `color`는 유효한 옵션으로, 알림의 강조 색상을 지정합니다.

Notifications API의 다른 유효한 옵션으로는 `badge`, `image`, `vibrate`, `sound`, `tag`, `renotify`, `requireInteraction`, `actions`, `silent`, `timestamp`, `data` 등이 있습니다.

#### 문제 6
**문제**: 사용자가 알림을 클릭했을 때 서비스 워커에서 발생하는 이벤트는 무엇인가요?

**정답**: notificationclick

**해설**: 사용자가 알림을 클릭했을 때 서비스 워커에서 발생하는 이벤트는 `notificationclick` 이벤트입니다. 이 이벤트는 사용자가 알림 자체나 알림의 액션 버튼을 클릭했을 때 발생하며, 이벤트 핸들러에서 알림 클릭에 대한 응답으로 특정 페이지를 열거나, 데이터를 가져오거나, 다른 작업을 수행할 수 있습니다. 일반적으로 `self.addEventListener('notificationclick', event => { ... })` 형태로 이벤트 핸들러를 등록합니다. `notificationtap`, `notificationopen`, `notificationselect`는 웹 표준 Notifications API에 존재하지 않는 이벤트입니다.

#### 문제 7
**문제**: 푸시 알림 구현의 올바른 순서는 무엇인가요?

**정답**: 권한 요청 → 구독 생성 → 서버에 구독 정보 전송 → 푸시 이벤트 처리

**해설**: 푸시 알림 구현의 올바른 순서는 다음과 같습니다:
1. **권한 요청**: 먼저 `Notification.requestPermission()`을 사용하여 사용자에게 알림 권한을 요청합니다. 사용자가 권한을 허용해야만 다음 단계로 진행할 수 있습니다.
2. **구독 생성**: 권한이 허용되면 `registration.pushManager.subscribe()`를 사용하여 푸시 서비스에 구독을 생성합니다. 이때 VAPID 공개 키와 같은 구독 옵션을 제공합니다.
3. **서버에 구독 정보 전송**: 생성된 구독 정보를 애플리케이션 서버에 전송하여 저장합니다. 이 정보는 나중에 서버가 푸시 메시지를 보낼 때 사용됩니다.
4. **푸시 이벤트 처리**: 서비스 워커에서 `push` 이벤트 핸들러를 등록하여 푸시 메시지가 도착했을 때 처리하고 알림을 표시합니다.

이 순서는 논리적인 흐름을 따르며, 각 단계는 이전 단계의 성공에 의존합니다. 다른 순서로는 구현이 불가능하거나 제대로 작동하지 않을 수 있습니다.

#### 문제 8
**문제**: 다음 중 푸시 알림의 모범 사례가 아닌 것은?

**정답**: 사용자가 웹사이트를 처음 방문했을 때 바로 알림 권한 요청하기

**해설**: 사용자가 웹사이트를 처음 방문했을 때 바로 알림 권한을 요청하는 것은 푸시 알림의 모범 사례가 아닙니다. 이러한 방식은 사용자에게 웹사이트의 가치를 보여줄 기회도 없이 권한을 요청하므로, 대부분의 사용자가 권한을 거부할 가능성이 높습니다. 또한 한 번 거부된 권한은 사용자가 브라우저 설정을 통해 직접 변경하지 않는 한 다시 요청하기 어렵습니다.

푸시 알림의 모범 사례는 다음과 같습니다:
- 사용자가 특정 작업(예: 뉴스레터 구독, 상품 구매 등)을 수행한 후에 권한 요청하기
- 관련된 여러 알림을 그룹화하여 사용자의 알림 피로도 줄이기
- 사용자별로 개인화된 알림을 제공하여 참여도 높이기
- 알림 빈도를 조절할 수 있는 옵션을 제공하여 사용자가 자신의 경험을 제어할 수 있게 하기

이러한 모범 사례를 따르면 사용자의 알림 수락률을 높이고, 알림의 효과를 극대화하며, 사용자 경험을 향상시킬 수 있습니다.

### 04-3 백그라운드 동기화

#### 문제 1
**문제**: Background Sync API의 주요 목적은 무엇인가요?

**정답**: 오프라인 상태에서 저장된 데이터를 온라인 상태가 되면 동기화

**해설**: Background Sync API의 주요 목적은 오프라인 상태에서 저장된 데이터를 온라인 상태가 되면 자동으로 동기화하는 것입니다. 이 API는 네트워크 연결이 불안정하거나 없는 상황에서도 사용자가 작업을 계속할 수 있게 하고, 네트워크 연결이 복원되면 자동으로 서버와 데이터를 동기화합니다. 이를 통해 오프라인 우선(offline-first) 웹 애플리케이션을 구축하고 사용자 경험을 크게 향상시킬 수 있습니다. 실시간 통신, 백그라운드 색상 동기화, 여러 기기 간의 설정 동기화는 Background Sync API의 주요 목적이 아닙니다.

#### 문제 2
**문제**: 백그라운드 동기화 작업을 등록하기 위해 사용하는 메서드는 무엇인가요?

**정답**: registration.sync.register()

**해설**: 백그라운드 동기화 작업을 등록하기 위해서는 `registration.sync.register()` 메서드를 사용합니다. 이 메서드는 서비스 워커 등록 객체(ServiceWorkerRegistration)의 `sync` 속성을 통해 접근할 수 있으며, 동기화 작업의 고유 식별자(태그)를 매개변수로 받습니다. 일반적으로 `navigator.serviceWorker.ready.then(registration => registration.sync.register('sync-tag'))` 형태로 사용됩니다. `navigator.serviceWorker.register()`는 서비스 워커를 등록하는 메서드이고, `self.addEventListener('sync')`는 서비스 워커에서 동기화 이벤트를 리스닝하는 메서드이며, `window.requestSync()`는 존재하지 않는 메서드입니다.

#### 문제 3
**문제**: 서비스 워커에서 백그라운드 동기화 이벤트를 처리하기 위해 리스닝해야 하는 이벤트는 무엇인가요?

**정답**: sync

**해설**: 서비스 워커에서 백그라운드 동기화 이벤트를 처리하기 위해 리스닝해야 하는 이벤트는 `sync` 이벤트입니다. 이 이벤트는 네트워크 연결이 복원되었을 때 서비스 워커에서 발생하며, 이벤트 핸들러에서 저장된 데이터를 서버에 전송하는 등의 동기화 작업을 수행할 수 있습니다. 일반적으로 `self.addEventListener('sync', event => { ... })` 형태로 이벤트 핸들러를 등록합니다. `background`, `online`, `synchronize`는 서비스 워커에서 백그라운드 동기화와 관련된 이벤트가 아닙니다.

#### 문제 4
**문제**: 오프라인 상태에서 데이터를 임시 저장하는 데 가장 적합한 스토리지 메커니즘은 무엇인가요?

**정답**: IndexedDB

**해설**: 오프라인 상태에서 데이터를 임시 저장하는 데 가장 적합한 스토리지 메커니즘은 IndexedDB입니다. IndexedDB는 대용량의 구조화된 데이터를 저장하고 효율적으로 검색할 수 있는 클라이언트 측 데이터베이스로, 서비스 워커에서도 접근할 수 있습니다. 또한 비동기적으로 작동하여 메인 스레드를 차단하지 않으며, 트랜잭션을 지원하여 데이터 무결성을 보장합니다. LocalStorage와 SessionStorage는 동기적으로 작동하여 성능 문제를 일으킬 수 있고 저장 용량이 제한적이며, 서비스 워커에서 직접 접근할 수 없습니다. Cookies는 용량 제한이 더 심하고 모든 HTTP 요청에 포함되어 네트워크 오버헤드를 발생시키므로 대량의 데이터 저장에 적합하지 않습니다.

#### 문제 5
**문제**: 주기적 백그라운드 동기화(Periodic Background Sync)를 등록하기 위해 사용하는 API는 무엇인가요?

**정답**: registration.periodicSync.register()

**해설**: 주기적 백그라운드 동기화(Periodic Background Sync)를 등록하기 위해 사용하는 API는 `registration.periodicSync.register()` 메서드입니다. 이 메서드는 서비스 워커 등록 객체(ServiceWorkerRegistration)의 `periodicSync` 속성을 통해 접근할 수 있으며, 동기화 작업의 고유 식별자(태그)와 최소 동기화 간격을 지정하는 옵션 객체를 매개변수로 받습니다. 일반적으로 `registration.periodicSync.register('update-tag', { minInterval: 24 * 60 * 60 * 1000 })` 형태로 사용됩니다. `registration.sync.register()`는 일반 백그라운드 동기화를 등록하는 메서드이고, `navigator.periodicSync.register()`와 `self.registerPeriodicSync()`는 존재하지 않는 메서드입니다.

#### 문제 6
**문제**: 다음 중 백그라운드 동기화의 장점이 아닌 것은? (복수 응답)

**정답**: 실시간 양방향 통신이 가능하다, 서비스 워커 없이도 사용할 수 있다

**해설**: 
- 실시간 양방향 통신이 가능하다: 이는 백그라운드 동기화의 장점이 아닙니다. 백그라운드 동기화는 기본적으로 단방향 통신 모델로, 클라이언트에서 서버로 데이터를 전송하는 데 중점을 둡니다. 실시간 양방향 통신은 WebSocket이나 Server-Sent Events와 같은 다른 기술이 더 적합합니다.
- 서비스 워커 없이도 사용할 수 있다: 이 역시 백그라운드 동기화의 장점이 아닙니다. Background Sync API는 서비스 워커에 의존하며, 서비스 워커 없이는 사용할 수 없습니다.
- 오프라인 상태에서도 사용자 작업을 저장할 수 있다: 이는 백그라운드 동기화의 실제 장점입니다. 사용자가 오프라인 상태에서도 작업을 계속할 수 있게 하고, 데이터를 로컬에 저장했다가 나중에 동기화할 수 있습니다.
- 네트워크 연결이 불안정한 환경에서 데이터 손실을 방지한다: 이 역시 백그라운드 동기화의 장점입니다. 네트워크 연결이 끊어지더라도 데이터를 안전하게 저장하고 나중에 전송할 수 있습니다.
- 서버의 부하를 줄일 수 있다: 이 역시 백그라운드 동기화의 장점입니다. 여러 요청을 배치 처리하거나 최적의 시간에 전송함으로써 서버 부하를 분산시킬 수 있습니다.

#### 문제 7
**문제**: 백그라운드 동기화 작업이 실패했을 때 브라우저는 어떻게 대응하나요?

**정답**: 일정 시간 후에 자동으로 재시도한다

**해설**: 백그라운드 동기화 작업이 실패했을 때 브라우저는 일정 시간 후에 자동으로 재시도합니다. 브라우저는 지수 백오프(exponential backoff) 알고리즘을 사용하여 점점 더 긴 간격으로 재시도하며, 일반적으로 몇 시간 또는 며칠에 걸쳐 여러 번 재시도합니다. 이는 일시적인 네트워크 문제나 서버 오류로 인한 실패를 극복하는 데 도움이 됩니다. 브라우저가 즉시 오류를 발생시키고 더 이상 시도하지 않거나, 사용자에게 오류 메시지를 표시하고 수동 재시도를 요청하거나, 항상 성공할 때까지 무한정 재시도하는 것은 아닙니다. 재시도 횟수와 간격은 브라우저마다 다를 수 있으며, 배터리 상태나 네트워크 유형 등의 요소에 따라 조정될 수 있습니다.

#### 문제 8
**문제**: 다음 중 백그라운드 동기화를 구현할 때의 모범 사례는 무엇인가요? (복수 응답)

**정답**: 동기화 상태에 대한 명확한 피드백 제공하기, 백그라운드 동기화가 지원되지 않는 브라우저를 위한 폴백 구현하기, 네트워크 요청 실패 시 재시도 전략 구현하기

**해설**: 
- 동기화 상태에 대한 명확한 피드백 제공하기: 이는 백그라운드 동기화의 모범 사례입니다. 사용자에게 데이터가 저장되었고 나중에 동기화될 것임을 알려주거나, 동기화가 진행 중이거나 완료되었음을 표시하는 것이 중요합니다.
- 백그라운드 동기화가 지원되지 않는 브라우저를 위한 폴백 구현하기: 이 역시 모범 사례입니다. 모든 브라우저가 Background Sync API를 지원하는 것은 아니므로, 지원되지 않는 경우 `online` 이벤트 리스너와 같은 대체 메커니즘을 구현해야 합니다.
- 네트워크 요청 실패 시 재시도 전략 구현하기: 이 역시 모범 사례입니다. 서버 오류나 네트워크 문제로 인해 동기화가 실패할 경우, 지수 백오프와 같은 재시도 전략을 구현하여 안정적인 동기화를 보장해야 합니다.
- 모든 네트워크 요청에 백그라운드 동기화 적용하기: 이는 모범 사례가 아닙니다. 백그라운드 동기화는 중요한 데이터 전송이나 사용자 작업과 같은 필수적인 요청에만 적용하는 것이 좋습니다. 모든 요청에 적용하면 불필요한 오버헤드가 발생할 수 있습니다.
- 백그라운드 동기화 지원 여부에 관계없이 동일한 코드 사용하기: 이 역시 모범 사례가 아닙니다. 브라우저 지원 여부를 확인하고 그에 맞게 코드를 분기하는 것이 중요합니다. 지원되지 않는 브라우저에서는 적절한 폴백 메커니즘을 사용해야 합니다.

## Chapter 05 프로그레시브 웹 앱(PWA)

### 05-1 PWA 개요

#### 문제 1
**문제**: PWA의 핵심 구성 요소가 아닌 것은?

**정답**: 데이터베이스 관리 시스템

**해설**: PWA(프로그레시브 웹 앱)의 핵심 구성 요소는 서비스 워커, 웹 앱 매니페스트, HTTPS입니다. 서비스 워커는 오프라인 기능, 백그라운드 동기화, 푸시 알림 등을 가능하게 하는 JavaScript 워커입니다. 웹 앱 매니페스트는 앱의 이름, 아이콘, 테마 색상 등을 정의하는 JSON 파일로, 설치 가능성을 제공합니다. HTTPS는 보안을 위해 필수적이며, 서비스 워커가 작동하기 위한 전제 조건입니다. 데이터베이스 관리 시스템은 PWA에서 데이터를 저장하는 데 사용될 수 있지만(예: IndexedDB), PWA의 핵심 구성 요소는 아닙니다.

#### 문제 2
**문제**: PWA가 설치 가능하기 위한 필수 조건이 아닌 것은?

**정답**: 서버 사이드 렌더링

**해설**: PWA가 설치 가능하기 위한 필수 조건은 유효한 웹 앱 매니페스트, 서비스 워커 등록, HTTPS 제공입니다. 웹 앱 매니페스트는 앱의 설치 정보를 제공하고, 서비스 워커는 오프라인 기능을 지원하며, HTTPS는 보안을 위해 필요합니다. 서버 사이드 렌더링은 웹 페이지의 초기 로딩 성능을 향상시키는 기술이지만, PWA의 설치 가능성과는 직접적인 관련이 없습니다. PWA는 클라이언트 사이드 렌더링이나 서버 사이드 렌더링 모두에서 구현될 수 있으며, 렌더링 방식은 설치 가능성의 필수 조건이 아닙니다.

#### 문제 3
**문제**: 다음 중 PWA의 특징으로 올바른 것은? (복수 응답)

**정답**: 홈 화면에 추가할 수 있다, 푸시 알림을 보낼 수 있다, 오프라인에서도 작동할 수 있다

**해설**: 
- 홈 화면에 추가할 수 있다: PWA는 웹 앱 매니페스트를 통해 홈 화면에 추가할 수 있으며, 이를 통해 네이티브 앱과 유사한 방식으로 실행할 수 있습니다.
- 푸시 알림을 보낼 수 있다: PWA는 Push API와 Notifications API를 사용하여 사용자에게 푸시 알림을 보낼 수 있습니다.
- 오프라인에서도 작동할 수 있다: 서비스 워커와 캐싱 전략을 통해 네트워크 연결 없이도 기본 기능을 사용할 수 있습니다.
- 항상 인터넷 연결이 필요하다: 이는 올바르지 않습니다. PWA의 주요 특징 중 하나는 오프라인에서도 작동할 수 있다는 점입니다.
- 앱 스토어를 통해서만 설치할 수 있다: 이 역시 올바르지 않습니다. PWA는 앱 스토어를 통하지 않고 브라우저에서 직접 설치할 수 있습니다.

#### 문제 4
**문제**: 앱 셸 아키텍처의 주요 목적은 무엇인가요?

**정답**: 초기 로딩 속도 향상

**해설**: 앱 셸 아키텍처의 주요 목적은 초기 로딩 속도를 향상시키는 것입니다. 앱 셸은 애플리케이션의 핵심 인프라와 UI(HTML, CSS, JavaScript, 기본 이미지 등)를 동적 콘텐츠와 분리하여, 서비스 워커를 통해 캐시합니다. 이를 통해 사용자가 애플리케이션을 방문할 때 기본 UI가 즉시 로드되고, 동적 콘텐츠는 필요에 따라 로드됩니다. 이 접근 방식은 빠른 초기 로딩, 일관된 UI, 네트워크 효율성, 오프라인 경험 등의 이점을 제공합니다. 서버 부하 감소, 데이터베이스 최적화, 배터리 사용량 감소는 앱 셸 아키텍처의 주요 목적이 아닙니다.

#### 문제 5
**문제**: 웹 앱 매니페스트에 포함되지 않는 정보는?

**정답**: 서비스 워커 스크립트

**해설**: 웹 앱 매니페스트는 PWA의 외관과 동작을 정의하는 JSON 파일로, 앱 이름, 아이콘 경로, 테마 색상 등의 정보를 포함합니다. 그러나 서비스 워커 스크립트는 웹 앱 매니페스트에 포함되지 않습니다. 서비스 워커는 별도의 JavaScript 파일로 구현되며, HTML 문서에서 `navigator.serviceWorker.register()` 메서드를 통해 등록됩니다. 웹 앱 매니페스트와 서비스 워커는 PWA의 핵심 구성 요소이지만, 서로 독립적으로 구현되고 관리됩니다. 웹 앱 매니페스트는 주로 설치 가능성과 외관에 관련된 정보를 제공하는 반면, 서비스 워커는 오프라인 기능, 푸시 알림 등의 기능적 측면을 담당합니다.

#### 문제 6
**문제**: PWA의 개발자 관점에서의 이점이 아닌 것은?

**정답**: 하드웨어에 대한 완전한 접근

**해설**: PWA의 개발자 관점에서의 이점은 단일 코드베이스로 여러 플랫폼 지원, 앱 스토어 승인 없이 즉시 배포, 웹 기술 활용 등이 있습니다. 그러나 하드웨어에 대한 완전한 접근은 PWA의 이점이 아닙니다. PWA는 웹 기술을 기반으로 하기 때문에, 네이티브 앱에 비해 하드웨어 접근이 제한적입니다. 웹 API를 통해 카메라, 마이크, 위치 정보 등 일부 하드웨어 기능에 접근할 수 있지만, 네이티브 앱처럼 모든 하드웨어 기능에 완전히 접근할 수는 없습니다. 이는 PWA의 한계 중 하나로, 특정 하드웨어 기능이 필요한 애플리케이션의 경우 네이티브 앱 개발이 더 적합할 수 있습니다.

#### 문제 7
**문제**: 서비스 워커가 PWA에서 수행하는 역할이 아닌 것은?

**정답**: 직접적인 DOM 조작

**해설**: 서비스 워커는 PWA에서 오프라인 작동 지원, 푸시 알림 처리, 백그라운드 동기화 등의 역할을 수행합니다. 그러나 직접적인 DOM 조작은 서비스 워커가 수행할 수 없는 역할입니다. 서비스 워커는 웹 페이지와 별도의 JavaScript 스레드에서 실행되며, DOM에 직접 접근할 수 없습니다. 서비스 워커가 웹 페이지의 DOM을 변경하려면 메시지 전달(postMessage)을 통해 웹 페이지와 통신해야 합니다. 이러한 제한은 서비스 워커가 백그라운드에서 실행되는 특성 때문에 존재하며, 웹 페이지의 UI 조작은 메인 스레드에서 처리해야 합니다.

### 05-2 매니페스트 파일

#### 문제 1
**문제**: 웹 앱 매니페스트 파일에서 홈 화면에 표시될 짧은 이름을 지정하는 속성은 무엇인가요?

**정답**: short_name

**해설**: 웹 앱 매니페스트 파일에서 홈 화면에 표시될 짧은 이름을 지정하는 속성은 `short_name`입니다. 이 속성은 공간이 제한된 홈 화면이나 앱 런처에서 사용되는 짧은 버전의 앱 이름을 정의합니다. 반면, `name` 속성은 앱의 전체 이름으로 설치 프롬프트나 스플래시 화면과 같이 더 많은 공간이 있는 곳에서 사용됩니다. `app_name`과 `display_name`은 웹 앱 매니페스트의 표준 속성이 아닙니다. 홈 화면에 표시될 앱 이름을 효과적으로 관리하기 위해서는 `name`과 `short_name` 모두 제공하는 것이 좋습니다.

#### 문제 2
**문제**: PWA가 설치 가능하기 위한 필수 조건이 아닌 것은?

**정답**: 데이터베이스 연결

**해설**: PWA가 설치 가능하기 위한 필수 조건은 유효한 웹 앱 매니페스트 파일, 서비스 워커 등록, HTTPS 제공 등이 있습니다. 그러나 데이터베이스 연결은 PWA의 설치 가능성과 관련이 없습니다. 데이터베이스는 애플리케이션의 데이터 저장 및 관리를 위한 것으로, PWA의 기능적 측면에 영향을 줄 수 있지만 설치 가능성의 필수 조건은 아닙니다. 브라우저가 PWA 설치 프롬프트를 표시하기 위해서는 유효한 웹 앱 매니페스트, HTTPS 환경, 서비스 워커 등록, 적절한 아이콘 등의 기술적 요구사항을 충족해야 합니다.

#### 문제 3
**문제**: 매니페스트 파일에서 애플리케이션이 표시되는 방식을 결정하는 속성은?

**정답**: display

**해설**: 매니페스트 파일에서 애플리케이션이 표시되는 방식을 결정하는 속성은 `display`입니다. 이 속성은 PWA가 사용자에게 어떻게 표시될지를 지정하며, 다음과 같은 값을 가질 수 있습니다: `fullscreen`(모든 브라우저 UI를 숨기고 전체 화면으로 표시), `standalone`(브라우저 UI를 숨기고 별도의 앱처럼 표시), `minimal-ui`(최소한의 브라우저 컨트롤을 표시), `browser`(일반 브라우저 탭에서와 같이 표시). 대부분의 PWA는 네이티브 앱과 유사한 경험을 제공하기 위해 `standalone` 모드를 사용합니다. `view`, `mode`, `appearance`는 웹 앱 매니페스트의 표준 속성이 아닙니다.

#### 문제 4
**문제**: 다음 중 웹 앱 매니페스트의 디스플레이 모드가 아닌 것은?

**정답**: windowed

**해설**: 웹 앱 매니페스트의 표준 디스플레이 모드에는 `fullscreen`, `standalone`, `minimal-ui`, `browser`가 있습니다. `windowed`는 표준 디스플레이 모드가 아닙니다. `fullscreen` 모드는 가능한 모든 화면 공간을 사용하며 브라우저 UI를 완전히 숨깁니다. `standalone` 모드는 네이티브 앱과 유사하게 표시되며, 브라우저 UI를 숨기고 별도의 창으로 실행됩니다. `minimal-ui` 모드는 기본적인 브라우저 컨트롤(뒤로 가기, 새로고침 등)을 표시합니다. `browser` 모드는 일반적인 브라우저 탭에서와 같이 표시됩니다. 디스플레이 모드 선택은 애플리케이션의 성격과 사용자 경험 요구사항에 따라 달라집니다.

#### 문제 5
**문제**: 매니페스트 파일에서 아이콘의 용도를 'maskable'로 지정하는 이유는 무엇인가요?

**정답**: 다양한 모양의 적응형 아이콘을 지원하기 위해

**해설**: 매니페스트 파일에서 아이콘의 용도를 'maskable'로 지정하는 이유는 다양한 모양의 적응형 아이콘을 지원하기 위해서입니다. 특히 Android 기기에서는 원형, 사각형, 둥근 사각형 등 다양한 모양의 아이콘을 사용하며, 'maskable' 아이콘은 이러한 다양한 모양에 맞게 조정될 수 있습니다. 'maskable' 아이콘은 중요한 콘텐츠가 안전 영역(safe zone) 내에 위치하도록 디자인되어, 어떤 모양으로 잘리더라도 아이콘의 핵심 요소가 보이도록 합니다. 이는 아이콘을 흑백으로 표시하거나, 그림자 효과를 추가하거나, 크기를 자동으로 조정하는 것과는 다른 목적을 가집니다.

#### 문제 6
**문제**: 다음 중 PWA 설치 프롬프트를 캡처하는 JavaScript 이벤트는?

**정답**: beforeinstallprompt

**해설**: PWA 설치 프롬프트를 캡처하는 JavaScript 이벤트는 `beforeinstallprompt`입니다. 이 이벤트는 브라우저가 PWA 설치 프롬프트를 표시하기 직전에 발생하며, 개발자는 이 이벤트를 캡처하여 기본 프롬프트 표시를 방지하고 사용자 정의 설치 버튼을 통해 프롬프트를 표시할 수 있습니다. 일반적으로 다음과 같이 사용됩니다:
```javascript
let deferredPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  showInstallButton();
});
```
이를 통해 개발자는 설치 경험을 더 잘 제어하고 사용자에게 적절한 시점에 설치를 유도할 수 있습니다. `oninstallprompt`, `installprompt`, `pwainstall`은 표준 이벤트가 아닙니다.

#### 문제 7
**문제**: 웹 앱 매니페스트 파일을 HTML 문서에 연결하는 올바른 방법은?

**정답**: `<link rel="manifest" href="/manifest.json">`

**해설**: 웹 앱 매니페스트 파일을 HTML 문서에 연결하는 올바른 방법은 `<link rel="manifest" href="/manifest.json">` 태그를 사용하는 것입니다. 이 태그는 HTML 문서의 `<head>` 섹션에 추가되어야 하며, `rel="manifest"` 속성은 이 링크가 웹 앱 매니페스트를 가리킨다는 것을 브라우저에 알려줍니다. `href` 속성은 매니페스트 파일의 경로를 지정합니다. 다른 옵션들은 올바른 방법이 아닙니다. `<script src="/manifest.json"></script>`는 JavaScript 파일을 로드하는 데 사용되고, `<meta name="manifest" content="/manifest.json">`은 유효한 HTML 태그이지만 매니페스트 파일을 연결하는 표준 방법이 아니며, `<import manifest from="/manifest.json">`은 유효한 HTML 태그가 아닙니다.

### 05-3 오프라인 경험 구현

#### 문제 1
**문제**: 오프라인 페이지를 제공하기 위해 서비스 워커에서 처리해야 하는 이벤트는?

**정답**: fetch

**해설**: 오프라인 페이지를 제공하기 위해 서비스 워커에서 처리해야 하는 이벤트는 `fetch` 이벤트입니다. 이 이벤트는 웹 애플리케이션에서 네트워크 요청이 발생할 때마다 서비스 워커에서 발생하며, 이를 가로채서 캐시된 응답을 제공하거나 오프라인 페이지로 대체할 수 있습니다. 서비스 워커의 `fetch` 이벤트 핸들러에서는 네트워크 요청이 실패할 경우 미리 캐시해둔 오프라인 페이지를 반환하는 방식으로 오프라인 경험을 구현합니다. `install` 이벤트는 서비스 워커가 설치될 때 발생하며 주로 필요한 리소스를 캐싱하는 데 사용되고, `activate` 이벤트는 서비스 워커가 활성화될 때 발생하며 주로 오래된 캐시를 정리하는 데 사용됩니다. `push` 이벤트는 푸시 알림과 관련된 이벤트로, 오프라인 페이지 제공과는 직접적인 관련이 없습니다.

#### 문제 2
**문제**: 네트워크 연결 상태가 변경될 때 발생하는 이벤트가 아닌 것은?

**정답**: navigate

**해설**: 네트워크 연결 상태가 변경될 때 발생하는 이벤트는 `online`과 `offline`입니다. `online` 이벤트는 브라우저가 네트워크에 연결되었을 때 발생하고, `offline` 이벤트는 네트워크 연결이 끊겼을 때 발생합니다. `connectionchange`는 Network Information API의 일부로 제안되었지만 아직 표준화되지 않았습니다. `navigate` 이벤트는 네트워크 상태 변경과 관련이 없으며, 사용자가 페이지 간 이동할 때 발생하는 이벤트입니다. 네트워크 상태 변경을 감지하기 위해서는 주로 `window.addEventListener('online', handler)`와 `window.addEventListener('offline', handler)`를 사용합니다.

#### 문제 3
**문제**: 오프라인 데이터 저장에 가장 적합한 API는? (복수 응답)

**정답**: IndexedDB, Cache API

**해설**: 오프라인 데이터 저장에 가장 적합한 API는 IndexedDB와 Cache API입니다.
- IndexedDB는 대용량의 구조화된 데이터를 저장하기 위한 클라이언트 측 데이터베이스로, 복잡한 데이터 구조와 쿼리를 지원하며 오프라인 애플리케이션 데이터를 저장하는 데 이상적입니다.
- Cache API는 서비스 워커와 함께 사용하여 HTTP 요청과 응답을 저장하며, 주로 정적 자산과 API 응답을 캐싱하는 데 적합합니다.
- localStorage는 간단한 키-값 쌍을 저장할 수 있지만, 용량이 제한적(일반적으로 5MB)이고 동기적으로 작동하여 성능 문제를 일으킬 수 있으므로 대량의 데이터나 복잡한 구조에는 적합하지 않습니다.
- Cookies는 용량이 매우 제한적(일반적으로 4KB)이고 모든 HTTP 요청에 포함되어 네트워크 오버헤드를 발생시키므로 오프라인 데이터 저장에 적합하지 않습니다.
- Web SQL은 더 이상 표준으로 개발되지 않는 deprecated API로, 새로운 프로젝트에서는 사용하지 않는 것이 좋습니다.

#### 문제 4
**문제**: 다음 중 오프라인 우선(Offline-First) 접근법의 특징이 아닌 것은?

**정답**: 네트워크 요청이 항상 우선시된다

**해설**: 오프라인 우선(Offline-First) 접근법의 특징이 아닌 것은 "네트워크 요청이 항상 우선시된다"입니다. 오프라인 우선 접근법은 네트워크 연결을 부가적인 향상으로 간주하고, 기본적으로 오프라인 상태에서도 작동하도록 애플리케이션을 설계하는 방식입니다. 이 접근법의 핵심은 로컬 데이터를 먼저 로드하고 표시한 후, 필요한 경우 네트워크에서 데이터를 가져와 업데이트하는 것입니다. 또한 사용자 작업을 로컬에 저장한 후 나중에 동기화하고, 핵심 콘텐츠를 먼저 로드한 후 추가 데이터는 네트워크 상태에 따라 점진적으로 로드하는 것이 오프라인 우선 접근법의 특징입니다. 네트워크 요청을 항상 우선시하는 것은 오히려 "온라인 우선(Online-First)" 접근법에 가깝습니다.

#### 문제 5
**문제**: 오프라인 상태에서 수행한 작업을 온라인 상태가 되었을 때 자동으로 동기화하는 API는?

**정답**: Background Sync API

**해설**: 오프라인 상태에서 수행한 작업을 온라인 상태가 되었을 때 자동으로 동기화하는 API는 Background Sync API입니다. 이 API는 서비스 워커와 함께 사용되며, 사용자가 오프라인 상태에서 수행한 작업(예: 폼 제출, 메시지 전송)을 등록하고, 네트워크 연결이 복구되면 자동으로 이러한 작업을 처리합니다. Background Sync API는 `registration.sync.register()` 메서드를 통해 동기화 작업을 등록하고, 서비스 워커의 `sync` 이벤트 핸들러에서 이를 처리합니다. Sync API, Web Sync API, Offline Sync API는 표준 웹 API가 아닙니다.

#### 문제 6
**문제**: 오프라인 경험 구현 시 충돌 해결 전략이 아닌 것은?

**정답**: 네트워크 우선 전략

**해설**: 오프라인 경험 구현 시 충돌 해결 전략이 아닌 것은 "네트워크 우선 전략"입니다. 네트워크 우선 전략은 캐싱 전략의 하나로, 네트워크 요청을 먼저 시도하고 실패할 경우 캐시로 폴백하는 방식을 의미합니다. 이는 충돌 해결 전략이 아니라 리소스 로딩 전략입니다. 오프라인 경험 구현 시 실제 충돌 해결 전략으로는 다음과 같은 것들이 있습니다:
- 클라이언트 우선 전략: 클라이언트의 변경 사항을 우선시하여 서버 데이터를 덮어씁니다.
- 서버 우선 전략: 서버의 데이터를 우선시하여 클라이언트 변경 사항을 무시합니다.
- 타임스탬프 기반 전략: 가장 최근에 수정된 데이터를 우선시합니다.
- 병합 전략: 가능한 경우 두 변경 사항을 병합합니다.
- 사용자 선택 전략: 충돌이 발생하면 사용자에게 어떤 버전을 유지할지 선택하게 합니다.

#### 문제 7
**문제**: 다음 중 효과적인 오프라인 페이지 설계의 요소가 아닌 것은?

**정답**: 자동 새로고침 기능

**해설**: 효과적인 오프라인 페이지 설계의 요소가 아닌 것은 "자동 새로고침 기능"입니다. 자동 새로고침은 오프라인 상태에서 계속해서 네트워크 요청을 시도하게 되어 배터리 소모를 증가시키고 사용자 경험을 저하시킬 수 있습니다. 대신, 사용자가 수동으로 새로고침할 수 있는 버튼을 제공하거나, 네트워크 상태가 변경될 때(`online` 이벤트 발생 시)에만 페이지를 새로고침하는 것이 더 효과적입니다. 효과적인 오프라인 페이지 설계의 요소로는 사용자 친화적인 오류 메시지(현재 상태를 명확하게 설명), 캐시된 콘텐츠 접근 제공(가능한 경우 이전에 로드된 콘텐츠 표시), 브랜딩 유지(일관된 디자인으로 신뢰성 유지) 등이 있습니다.

## Chapter 06 서비스 워커 고급 주제

### 06-1 성능 최적화

#### 문제 1
**문제**: 서비스 워커를 사용한 리소스 우선순위 지정 방법으로 올바르지 않은 것은?

**정답**: 모든 리소스에 항상 네트워크 우선 전략 적용

**해설**: 모든 리소스에 항상 네트워크 우선 전략을 적용하는 것은 효과적인 리소스 우선순위 지정 방법이 아닙니다. 리소스의 특성과 중요도에 따라 다양한 캐싱 전략을 적용하는 것이 성능 최적화에 더 효과적입니다. 예를 들어, 자주 변경되지 않는 정적 자산(CSS, JavaScript, 이미지 등)에는 캐시 우선 전략이 적합하고, 자주 변경되는 API 데이터에는 네트워크 우선 또는 스테일-와일-리밸리데이트 전략이 적합합니다. fetch 이벤트에서 리소스 유형에 따라 다른 캐싱 전략을 적용하거나, 중요 리소스에 preload 리소스 힌트를 사용하거나, 서비스 워커 설치 시 중요 리소스를 프리캐싱하는 것은 모두 효과적인 리소스 우선순위 지정 방법입니다.

#### 문제 2
**문제**: 프리캐싱과 런타임 캐싱의 차이점으로 올바른 것은?

**정답**: 프리캐싱은 서비스 워커 설치 시 발생하고, 런타임 캐싱은 사용자가 리소스를 요청할 때 발생한다

**해설**: 프리캐싱과 런타임 캐싱의 주요 차이점은 캐싱이 발생하는 시점입니다. 프리캐싱은 서비스 워커가 설치될 때 미리 정의된 리소스를 캐시에 저장하는 방식으로, 주로 애플리케이션의 핵심 리소스(앱 셸, 기본 HTML, CSS, JavaScript 등)를 대상으로 합니다. 반면, 런타임 캐싱은 사용자가 애플리케이션을 사용하는 동안 요청되는 리소스를 동적으로 캐시하는 방식입니다. 프리캐싱은 애플리케이션의 즉시 오프라인 사용과 빠른 로딩을 가능하게 하고, 런타임 캐싱은 사용자의 실제 사용 패턴에 따라 필요한 리소스만 캐시하여 캐시 공간을 효율적으로 사용합니다. 두 전략을 적절히 조합하면 웹 애플리케이션의 성능을 크게 향상시킬 수 있습니다.

#### 문제 3
**문제**: 네트워크 요청 최적화 기법으로 올바른 것은? (복수 응답)

**정답**: 여러 개의 작은 요청을 하나의 배치 요청으로 병합, 조건부 요청 헤더(If-Modified-Since, If-None-Match) 활용, 중요한 도메인에 미리 연결(preconnect)

**해설**: 
- 여러 개의 작은 요청을 하나의 배치 요청으로 병합하는 것은 유효한 네트워크 요청 최적화 기법입니다. 이를 통해 네트워크 오버헤드를 줄이고 전체 로딩 시간을 단축할 수 있습니다.
- 조건부 요청 헤더(If-Modified-Since, If-None-Match)를 활용하는 것도 유효한 최적화 기법입니다. 이를 통해 리소스가 변경되지 않았을 때 불필요한 데이터 전송을 줄일 수 있습니다.
- 중요한 도메인에 미리 연결(preconnect)하는 것도 유효한 최적화 기법입니다. 이를 통해 DNS 조회, TCP 핸드셰이크, TLS 협상 등의 연결 설정 시간을 미리 처리하여 실제 리소스 요청 시 지연 시간을 줄일 수 있습니다.
- 모든 API 응답을 무기한 캐싱하는 것은 적절한 최적화 기법이 아닙니다. 이는 오래된 데이터를 계속 제공하게 되어 사용자에게 잘못된 정보를 제공할 수 있습니다.
- 모든 이미지 요청을 차단하는 것도 적절한 최적화 기법이 아닙니다. 이는 사용자 경험을 저하시키고 웹사이트의 가치를 떨어뜨릴 수 있습니다.

#### 문제 4
**문제**: 서비스 워커 성능 측정 및 모니터링에 사용할 수 있는 도구는? (복수 응답)

**정답**: Chrome DevTools, Web Performance API, Lighthouse

**해설**: 
- Chrome DevTools는 서비스 워커 성능 측정 및 모니터링에 사용할 수 있는 강력한 도구입니다. Application 탭에서 서비스 워커 상태를 확인하고, Network 탭에서 캐시된 응답을 확인하며, Performance 탭에서 서비스 워커 활동을 분석할 수 있습니다.
- Web Performance API는 JavaScript를 통해 웹 애플리케이션의 성능을 측정하고 분석할 수 있는 API 집합입니다. 서비스 워커에서 리소스 로딩 시간을 측정하고 성능 메트릭을 수집하는 데 사용할 수 있습니다.
- Lighthouse는 Google에서 개발한 오픈 소스 자동화 도구로, 웹 페이지의 품질을 개선하기 위한 감사를 수행합니다. PWA 카테고리에서 서비스 워커 관련 항목을 확인하고, Performance 카테고리에서 전반적인 성능 점수를 확인할 수 있습니다.
- CSS Validator는 CSS 코드의 유효성을 검사하는 도구로, 서비스 워커 성능 측정과는 직접적인 관련이 없습니다.
- Network Monitor는 일반적인 용어로, 특정 도구를 가리키지 않습니다. 브라우저의 네트워크 모니터링 기능은 Chrome DevTools의 Network 탭에 포함되어 있습니다.

#### 문제 5
**문제**: 다음 중 서비스 워커를 사용한 성능 최적화의 이점이 아닌 것은?

**정답**: 서버 측 데이터베이스 쿼리 최적화

**해설**: 서버 측 데이터베이스 쿼리 최적화는 서비스 워커를 사용한 성능 최적화의 이점이 아닙니다. 서비스 워커는 클라이언트 측 기술로, 서버 측 데이터베이스 쿼리에 직접적인 영향을 미치지 않습니다. 서버 측 최적화는 서버 코드와 데이터베이스 설계를 통해 이루어져야 합니다. 반면, 반복 방문 시 페이지 로딩 속도 향상, 네트워크 요청 감소로 데이터 사용량 절약, 서버 부하 감소는 모두 서비스 워커를 사용한 성능 최적화의 실제 이점입니다. 서비스 워커는 캐싱을 통해 네트워크 요청을 줄이고, 이미 방문한 페이지를 빠르게 로드하며, 결과적으로 서버에 대한 요청을 감소시켜 서버 부하를 줄이는 데 도움이 됩니다.

